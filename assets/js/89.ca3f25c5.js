(window.webpackJsonp=window.webpackJsonp||[]).push([[89],{418:function(o,e,s){"use strict";s.r(e);var i=s(4),n=Object(i.a)({},(function(){var o=this,e=o._self._c;return e("ContentSlotsDistributor",{attrs:{"slot-key":o.$parent.slotKey}},[e("p",[o._v("session/cookie")]),o._v(" "),e("ol",[e("li",[o._v("什么是状态管理\n将客户端(浏览器)与服务器之间多次交互当作一个整体来看，并将多次交互所涉及的数据(状态)保存下来。")]),o._v(" "),e("li",[o._v("如何进行状态管理")])]),o._v(" "),e("ul",[e("li",[o._v("第一类方式：将状态保存在客户端（Cookie）\n服务端存储一个 session对象 {key: value} key放置cookie中 通过cookie的key取到value value就不用暴露至客户端\na. cookie是一种客户端的状态管理技术\nb. 当浏览器向服务器发送请求时，服务器会将少量的数据以set-cookie消息头的方式发送给浏览器，浏览器会将这些数据保存下来。当浏览器再次访问服务器时，会将这些数据以cookie消息头的方式发送给服务器。\nc. cookie可被用户禁止。\nd. cookie不安全,敏感数据，比如密码，帐号等等需加密。\ne. cookie大小有限制，大约是4k左右(具体大小跟浏览器有关)。\nf. cookie个数有限制，大约是300个(具体个数跟浏览器有关)。\ng.  cookie只能够保存字符串。")]),o._v(" "),e("li",[o._v("第二类方式: 将状态保存在服务器端(Session)\na. session是一种服务器端的状态管理技术。\nb. 当浏览器访问服务器时，服务器创建一个session对象(该对象有一个唯一的id号，称之为sessionId),服务器在默认情况下，会将sessionId以cookie的方式(set-cookie消息头)发送给浏览器,浏览器会将sessionId保存到内存。当浏览器再次访问服务器时，会将sessionId发送给服务器，服务器依据sessionId就可找到之前创建的session对象。")])]),o._v(" "),e("p",[o._v("Token(JWT)")]),o._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",[e("code",[o._v("      令牌头 payload hash\n")])])]),e("p",[o._v("token结构 base64·base64· hash")]),o._v(" "),e("ol",[e("li",[o._v("签名: 默认使用base64对payload编码,使用hs256算法对令牌头,payload和密钥进行签名生成哈希")]),o._v(" "),e("li",[o._v("验证: 默认使用hs256算法对令牌中数据签名并将结果和令牌中哈希对比")])]),o._v(" "),e("p",[o._v("Oauth2")]),o._v(" "),e("p",[o._v("客户端 => 服务器 拉取github 页面 => 登录 => 返回code => 使用code换取令牌")]),o._v(" "),e("p",[o._v("SSO")]),o._v(" "),e("p",[o._v("单点登录 => A 跳转至认证服务器 => 登录返回token => 核实token 放入登录态至A > B登录 在认证服务器查询登录 有则直接返回")])])}),[],!1,null,null,null);e.default=n.exports}}]);