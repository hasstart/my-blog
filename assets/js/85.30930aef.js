(window.webpackJsonp=window.webpackJsonp||[]).push([[85],{414:function(t,e,v){"use strict";v.r(e);var _=v(4),a=Object(_.a)({},(function(){var t=this,e=t._self._c;return e("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[e("h2",{attrs:{id:"异步编程"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#异步编程"}},[t._v("#")]),t._v(" 异步编程")]),t._v(" "),e("ol",[e("li",[t._v("Js的执行环境是单线程的")]),t._v(" "),e("li",[t._v("I/O处理需要回调函数异步处理")]),t._v(" "),e("li",[t._v("前端异步IO可以消除UI阻塞,提高用户体验")]),t._v(" "),e("li",[t._v("而放在后端则可以提高CPU和内存利用率")])]),t._v(" "),e("p",[t._v("异步方案")]),t._v(" "),e("ul",[e("li",[t._v("callback")]),t._v(" "),e("li",[t._v("promise")]),t._v(" "),e("li",[t._v("gennerator")]),t._v(" "),e("li",[t._v("async/await")]),t._v(" "),e("li",[t._v("事件驱动(事件监听)")]),t._v(" "),e("li",[t._v("发布/订阅")])]),t._v(" "),e("h2",{attrs:{id:"数据库"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#数据库"}},[t._v("#")]),t._v(" 数据库")]),t._v(" "),e("p",[t._v("关系型数据库 mySQL")]),t._v(" "),e("p",[t._v("inster\nupdate\ndelete\ntruncate")]),t._v(" "),e("p",[t._v("查询")]),t._v(" "),e("ul",[e("li",[e("p",[t._v("select  from where order by")])]),t._v(" "),e("li",[e("p",[t._v("select form where group by")])])]),t._v(" "),e("h2",{attrs:{id:"http缓存机制"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#http缓存机制"}},[t._v("#")]),t._v(" http缓存机制")]),t._v(" "),e("blockquote",[e("p",[t._v("当浏览器加载一个页面时.html引用的外部资源也会被加载,如 css js 图片,每次加载html都会进行资源加载,,带来资源浪费, http缓存为了解决这些问题")])]),t._v(" "),e("ol",[e("li",[t._v("提高首屏加载速度 > 优化用户体验")]),t._v(" "),e("li",[t._v("减少流量消耗")]),t._v(" "),e("li",[t._v("减轻服务器压力")])]),t._v(" "),e("ul",[e("li",[t._v("基本原理")])]),t._v(" "),e("ol",[e("li",[t._v("浏览器在加载资源时，根据请求头的expires和cache-control判断是否命中强缓存，是则直接从缓存读取资源，不会发请求到服务器。")]),t._v(" "),e("li",[t._v("如果没有命中强缓存，浏览器一定会发送一个请求到服务器，通过last-modified和etag验证资源是否命中协商缓存，如果命中，服务器会将这个请求返回，但是不会返回这个资源的")])]),t._v(" "),e("ul",[e("li",[t._v("强缓存")])]),t._v(" "),e("ol",[e("li",[e("p",[t._v("expires\nExpires是http1.0提出的一个表示资源过期时间的header，它描述的是一个绝对时间，由服务器返回。\nExpires 受限于本地时间，如果修改了本地时间，可能会造成缓存失效\nExpires: Wed, 11 May 2018 07:20:00 GMT")])]),t._v(" "),e("li",[e("p",[t._v("cache-control")])])]),t._v(" "),e("ul",[e("li",[e("p",[t._v("cache-control: max-age=xxxx，public\n客户端和代理服务器都可以缓存该资源；\n客户端在xxx秒的有效期内，如果有请求该资源的需求的话就直接读取缓存,statu code:200 ，如果用户做了刷新操作，就向服务器发起http请求")])]),t._v(" "),e("li",[e("p",[t._v("cache-control: max-age=xxxx，private\n只让客户端可以缓存该资源；代理服务器不缓存\n客户端在xxx秒内直接读取缓存,statu code:200")])]),t._v(" "),e("li",[e("p",[t._v("cache-control: max-age=xxxx，immutable\n客户端在xxx秒的有效期内，如果有请求该资源的需求的话就直接读取缓存,statu code:200 ，即使用户做了刷新操作，也不向服务器发起http请求")])]),t._v(" "),e("li",[e("p",[t._v("cache-control: no-cache\n跳过设置强缓存，但是不妨碍设置协商缓存；一般如果你做了强缓存，只有在强缓存失效了才走协商缓存的，设置了no-cache就不会走强缓存了，每次请求都回询问服务端。")])]),t._v(" "),e("li",[e("p",[t._v("cache-control: no-store\n不缓存，这个会让客户端、服务器都不缓存，也就没有所谓的强缓存、协商缓存了。")])])]),t._v(" "),e("ol",[e("li",[t._v("协商缓存")])]),t._v(" "),e("ul",[e("li",[t._v("last-modified / if-modified-Since")])]),t._v(" "),e("p",[t._v("Last-Modified 表示本地文件最后修改日期，浏览器会在request header加上If-Modified-Since（上次返回的Last-Modified的值），询问服务器在该日期后资源是否有更新，有更新的话就会将新的资源发送回来")]),t._v(" "),e("p",[t._v("但是如果在本地打开缓存文件，就会造成 Last-Modified 被修改，所以在 HTTP / 1.1 出现了 ETag")]),t._v(" "),e("ul",[e("li",[t._v("etag/if-none-match")])]),t._v(" "),e("p",[t._v("ETag的优先级比Last-Modified更高\nEtag就像一个指纹，资源变化都会导致ETag变化，跟最后修改时间没有关系，ETag可以保证每一个资源是唯一的")]),t._v(" "),e("p",[t._v("If-None-Match的header会将上次返回的Etag发送给服务器，询问该资源的Etag是否有更新，有变动就会发送新的资源回来")]),t._v(" "),e("p",[t._v("一些文件也许会周期性的更改，但是他的内容并不改变(仅仅改变的修改时间)，这个时候我们并不希望客户端认为这个文件被修改了，而重新GET；\n某些文件修改非常频繁，比如在秒以下的时间内进行修改，(比方说1s内修改了N次)，If-Modified-Since能检查到的粒度是s级的，这种修改无法判断(或者说UNIX记录MTIME只能精确到秒)；\n某些服务器不能精确的得到文件的最后修改时间。")]),t._v(" "),e("p",[e("img",{attrs:{src:"/http-cache.png",alt:"http缓存"}})])])}),[],!1,null,null,null);e.default=a.exports}}]);