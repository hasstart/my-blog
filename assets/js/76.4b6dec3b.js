(window.webpackJsonp=window.webpackJsonp||[]).push([[76],{405:function(v,_,p){"use strict";p.r(_);var a=p(4),e=Object(a.a)({},(function(){var v=this,_=v._self._c;return _("ContentSlotsDistributor",{attrs:{"slot-key":v.$parent.slotKey}},[_("h2",{attrs:{id:"前端性能平台"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#前端性能平台"}},[v._v("#")]),v._v(" 前端性能平台")]),v._v(" "),_("p",[v._v("前端性能平台是一个 Web 系统，主要包括后台的性能数据处理和前台的可视化展示两部分。数据处理后台主要是对 SDK 上报后的性能指标进行处理和运算，具体包括数据入库、数据清洗、数据计算，做完这些后，前台会对结果进行可视化展现，我们借助它就可以实时监督前端的性能情况。主要对当前用户关注的性能模块进行展示，内容包括首屏时间、秒开率和采样PV。")]),v._v(" "),_("p",[v._v("性能平台技术架构图")]),v._v(" "),_("p",[_("img",{attrs:{src:"/performance/platform_1.png",alt:"性能平台技术架构图"}})]),v._v(" "),_("p",[v._v("这是具体的技术架构图，从底层到前台大致情况如下：")]),v._v(" "),_("ul",[_("li",[v._v("数据接入层，主要是接收 SDK上报的性能数据，做数据处理后入库，包含的技术有 Node.js、Node-sechdule、Node-mailer；")]),v._v(" "),_("li",[v._v("数据计算层，会对性能数据做计算处理，需要的技术有 Kafka、Spark、Hive、HDFS；")]),v._v(" "),_("li",[v._v("存储层，包括 MySQL + MongoDB ，性能平台需要的数据会来这里；")]),v._v(" "),_("li",[v._v("平台层，也就是展示给用户的部分，需要的技术有 React、Ant design、Antv、Less。")])]),v._v(" "),_("h3",{attrs:{id:"性能数据处理后台"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#性能数据处理后台"}},[v._v("#")]),v._v(" 性能数据处理后台")]),v._v(" "),_("p",[v._v("想要搭建性能平台，我们先来看它的性能处理后台情况。一般性能 SDK 上报数据的处理过程是这样的：")]),v._v(" "),_("p",[v._v("客户端借助 SDK 上报性能数据指标，数据接入层（图中绿色部分）接收相应数据，并做协议转换等简单处理后，作为生产者向 Kafka 写入数据；")]),v._v(" "),_("p",[v._v("数据计算层（图中橙色部分）作为消费者，从 Kafka 读数据存入 Hive（Hadoop平台的存储表），Hadoop 平台借助 Spark 做数据分析计算；")]),v._v(" "),_("p",[v._v("借助 Hive 提供的接口，数据计算层使用 SQL 语句从 Hive 拉取计算后的数据到数据库平台（MongoDB），平台层取出数据，准备数据可视化展现的数据。")]),v._v(" "),_("p",[v._v("上述数据流程，对应的性能数据后台的搭建过程如下：")]),v._v(" "),_("p",[v._v("第一步是入库，客户端借助 SDK 上报性能数据指标后，需要后端服务层的处理，这里我们选取的是 NodeJS 做后端，利用 Controller 层对数据做处理。")]),v._v(" "),_("p",[v._v("为了避免数据库出现“脏数据”（如空数据、异常数据），影响后续数据处理，我们将 SDK 上报的数据通过 URL 解析成 key-value 格式的数据，对数据进行空数据删除，异常数据舍弃等操作。然后我们让数据写进消息队列 Kafka。")]),v._v(" "),_("p",[v._v("为什么不是直接存入 Hive 呢？")]),v._v(" "),_("p",[v._v("因为客户端上报的性能数据量和用户规模有关。如果直接入库到 Hive，遇到高并发的时候，会因为服务器扛不住而导致数据丢失。与此同时，因为数据下游（数据的使用方，如数据清洗计算平台，性能预警模块）会有多个数据接收端，直接入库的话也会造成数据重复。")]),v._v(" "),_("p",[v._v("所以最好我们选择 Kafka，先让数据写进消息队列。Kafka 能通过缓存，慢慢接收这些数据，降低流量洪峰压力。同时，消息队列还有接收数据后将其删除的特点，可以避免数据重复的问题。")]),v._v(" "),_("p",[v._v("第二步，对 Kafka 中的数据，做数据清洗和数据计算。")]),v._v(" "),_("p",[v._v("数据清洗，是指针对性能上报单条数据进行核对校验的过程。所清洗的数据包括：")]),v._v(" "),_("ul",[_("li",[v._v("对重复数据的处理，即同一个用户网络出错时，多次重试导致上传了好几条首屏时间相关的数据；")]),v._v(" "),_("li",[v._v("对缺失数据的处理，虽然上报了首屏时间，但白屏时间或者卡顿时间计算时没能给出；")]),v._v(" "),_("li",[v._v("对错误数据的处理，即数据超出正常范围，出现负值或者超出极大值的情况。")])]),v._v(" "),_("p",[v._v("这几种类型数据问题如果不处理，最终会影响计算结果的准确性。那么该怎么处理呢？")]),v._v(" "),_("ul",[_("li",[v._v("遇到重复数据，直接去重删除即可。")]),v._v(" "),_("li",[v._v("遇到缺失数据，我们在 Spark 平台上，先根据上报的 Performance 数据进行计算补全，如果无法补全的，就直接舍弃掉，不然会出现后续无法入库的情况。")]),v._v(" "),_("li",[v._v("遇到超出正常范围的数据，如负值或者超过 10 秒以上的数据，把它当作无效数据，直接舍弃掉。")])]),v._v(" "),_("p",[v._v("做完数据清洗之后，我们还需要使用 Spark 做数据计算，为可视化展现准备数据。具体需要做以下数据计算：")]),v._v(" "),_("p",[v._v("首屏时间分布的计算，1s ～ 2s 占比多少，2s ～ 4s 占比多少；")]),v._v(" "),_("p",[v._v("秒开率的计算，首屏时间小于等于 1 秒的数据占比；")]),v._v(" "),_("p",[v._v("页面瀑布流时间的计算。")]),v._v(" "),_("p",[v._v("其中，页面瀑布流时间是对首屏时间的细分，包括 DNS 查询、TCP链接、请求耗时、内容传输、资源解析、DOM 解析和资源加载的时间。这些细分时间点，是我们根据 SDK 上报的 Performance 接口数据指标计算出来的，前端工程师根据页面瀑布流时间，可以快速定位性能瓶颈点出现在哪个环节。")]),v._v(" "),_("p",[v._v("第三步，准备性能前台所需的可视化数据。")]),v._v(" "),_("p",[v._v("为了完成前台展现，性能平台需要登录功能，还需要做一些用户关注的模块信息，比如前端开发者添加关注的业务模块。我们可以用关系数据库去存储这些数据，具体可以选择 MySQL完成账号权限系统和关注业务模块对应的数据表。")]),v._v(" "),_("p",[v._v("而性能数据，因为都是单条性能信息，相互之间并没有什么关系，可以用 MongoDB 做存储。具体来说，我们可以用 NodeJS 提供的定时脚本（Node-sechdule）从 Spark 取到数据导入到 MongoDB 中。")]),v._v(" "),_("h3",{attrs:{id:"前端数据可视化展示前台"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#前端数据可视化展示前台"}},[v._v("#")]),v._v(" 前端数据可视化展示前台")]),v._v(" "),_("p",[v._v("前端数据可视化展现前台，整体上只有两个页面，大盘页和详情页。")]),v._v(" "),_("p",[v._v("大盘页包括一个个业务的性能简图。每一个性能简图包括首屏时间、秒开率、采样 PV 数据。点击性能简图上的“进入详情”链接，就可以进入详情页。初次进入大盘页的时候，需要你登录并关注相关的业务，然后就可以在大盘首页看到相关的性能情况。")]),v._v(" "),_("p",[v._v("详情页的设计的初衷是为了对性能简图做进一步的补充，除了展示对应性能简图的秒开率、性能均值细节、白屏均值细节之外，还会展示终端信息，比如多少比例在IOS端，多少比例在Android端，以方便用户根据不同场景去做优化。")]),v._v(" "),_("p",[_("img",{attrs:{src:"/performance/platform_2.png",alt:"详情页性能均值"}})]),v._v(" "),_("p",[v._v("详情页性能均值")]),v._v(" "),_("p",[_("img",{attrs:{src:"/performance/platform_3.png",alt:"详情页终端类型"}})]),v._v(" "),_("p",[v._v("详情页终端类型")]),v._v(" "),_("p",[v._v("同时，为了解秒开率不达标原因或者首屏时间变慢的细节在哪里，我们会给出页面加载瀑布流，前面数据处理阶段已经提到可以使用的数据（包括 DNS 查询、TCP链接、请求耗时、内容传输、资源解析、DOM 解析和资源加载的时间），套用 AntV （阿里巴巴集团的数据可视化方案）的瀑布流模板即可完成数据展现。")]),v._v(" "),_("p",[_("img",{attrs:{src:"/performance/platform_4.png",alt:"页面加载瀑布流"}})]),v._v(" "),_("p",[v._v("页面加载瀑布流")]),v._v(" "),_("p",[v._v("那么，大盘页和详情页如何实现的呢？")]),v._v(" "),_("p",[v._v("首先是前端展示技术栈的选择，对应技术架构图中的淡黄色部分，因为这两个页面都属于 PC 端后台页面，主要给公司前端开发者使用，功能上更多是数据可视化展示，非常适合用 React 技术栈做开发。")]),v._v(" "),_("p",[v._v("为了更好实现首屏时间、秒开率和采用 PV 的功能效果，我们使用 AntdPro 的模板，相关的配套的数据可视化方案，我推荐 Antv，因为它能够满足我们在首屏时间、秒开率等性能指标的展示需求，用起来比较简单（开箱即用），功能灵活且扩展性强（比如秒开率部分，要自定义一些图形，能够较好满足）。")]),v._v(" "),_("p",[v._v("大盘页和详情页的数据展示效果比较丰富多样，相应的 CSS 代码逻辑就比较复杂，为了让 CSS代码更容易维护和扩展，CSS 方面可以选用 Less 框架。")]),v._v(" "),_("p",[v._v("接下来是前后端交互方面，为了让前后台更独立，大盘页、详情页与后端的通信通过 HTTP 接口来实现，使用 nginx 作为 Web Server。为了让传输更高效，我们采用 compression 对 HTTP 传输内容进行 GZip 压缩处理。")]),v._v(" "),_("p",[v._v("最后是后台服务部分，为了让性能平台开发过程更简单，效率更高，同时平台本身的性能体验更流畅，后台服务方面可以选用 Egg.js（基于 NodeJS 的开发框架）做开发，进行数据处理和存储服务。")]),v._v(" "),_("p",[v._v("为了解决监控预警的问题，我们借助 Node-schedule 做调度和定时任务的处理，通过 node-mailer 进行邮件报警。有关预警部分的实现细节，我会在下一讲展开介绍。")]),v._v(" "),_("h3",{attrs:{id:"小结"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#小结"}},[v._v("#")]),v._v(" 小结")]),v._v(" "),_("p",[_("img",{attrs:{src:"/performance/platform_5.png",alt:"小结"}})]),v._v(" "),_("h2",{attrs:{id:"监控预警"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#监控预警"}},[v._v("#")]),v._v(" 监控预警")]),v._v(" "),_("p",[v._v("监控预警部分，我们借助 Node-schedule 做调度和定时任务的处理，通过 node-mailer 进行邮件报警。具体来说我们通过以下几步来实现。")]),v._v(" "),_("p",[v._v("第一步，准备预警数据。")]),v._v(" "),_("p",[v._v("在做完数据清洗之后，一个分支使用 Spark 做计算，另外一个分支使用 Flink 实时数据计算。这两者的区别在于后者的数据是实时处理的，因为监控预警如果不实时的话，就没有意义了。有关数据的处理，我是这样做的：超过 2s 的数据，或者认定为卡顿的数据，直接标记为预警数据。实际当中你也可以根据情况去定义和处理。")]),v._v(" "),_("p",[v._v("第二步，我们借助 Node-schedule，用一批定时任务将预警数据通过 Node.js，拉取数据到 MongoDB 的预警表中。")]),v._v(" "),_("p",[v._v("第三步，预警的展示流程。根据预警方式不同，样式展示也不同。具体来说，预警的方式有三种：企业微信报警通知、邮件报警通知、短信报警通知。")]),v._v(" "),_("p",[v._v("以手机列表页为例，性能标准是首屏时间 1.5s，秒开率 90%，超过这个标准就会在性能平台预警模块展示，按照严重程度倒序排列展示。如果超出 10%，平台上会标红展示，并会发企业微信报警通知；如果超过 20%，会发借助 node-mailer 做邮件报警；如果超出 30%，会发短信报警通知。")]),v._v(" "),_("p",[v._v("注意，预警通知需要用到通信资源，为了避免数据量太大而浪费资源，一般对 App 首页核心的导航位进行页面监控即可。")]),v._v(" "),_("h2",{attrs:{id:"问题诊断"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#问题诊断"}},[v._v("#")]),v._v(" 问题诊断")]),v._v(" "),_("p",[v._v("当预警功能做好后，前端性能平台就可以对重要指标进行实时监督了。当发现性能问题——不论是我们自己发现还是用户反馈，都需要先对问题进行诊断，然后看情况是否需要进一步采取措施。")]),v._v(" "),_("p",[v._v("一般问题诊断时需要先确认是共性问题还是个例问题。如果是共性问题，那接下来我们就开始诊断和优化；如果是个例问题，是因为偶发性因素导致的（如个人的网络抖动、手机内存占用太多、用户连了代理等），则不需要进行专门优化。")]),v._v(" "),_("p",[v._v("那怎么判断呢？")]),v._v(" "),_("p",[v._v("一般共性问题，我们可以通过大量用户的数据指标是否正常来判断。具体来说，当前端工程师遇到用户来反馈某个性能问题时，先去性能平台看性能指标，如果性能指标中的首屏时间的均值出现异常，就是共性问题。然后再去看究竟是哪个终端机型下的情况，加载瀑布流是怎样的，会慢在哪个环节。")]),v._v(" "),_("p",[v._v("以手机列表页某次加载慢的问题为例，某同事收到天津用户反馈说发布页面加载比较慢，他是怎么做的呢？")]),v._v(" "),_("p",[v._v("他先是看了性能平台，发现在中国移动网络下，发布页面的首屏时间均值很长，超过了 3s，说明这是共性问题。然后他看了发布页面的加载瀑布流时间后，发现一个负责上传图片的 JS 文件加载特别慢。原因是它在资源加载时被阻塞住了，阻塞它的是一个负责对图片上传后实施滤镜功能的文件。这个文件显然可以延迟加载，即上传完成后再加载都可以。于是他调整完加载策略，解决了用户反馈的问题。")]),v._v(" "),_("p",[v._v("如果我们发现大量用户的首屏指标（首屏时间均值和分位值）没问题，就可以判断为个例问题。有别于共性问题可以从平台上定位出具体是哪个瓶颈点，个例问题一般需要客服联系用户去解决，不需要代码层面做什么。")]),v._v(" "),_("p",[v._v("根据我过往对性能优化方面的经验，我整理了一个诊断清单：")]),v._v(" "),_("ul",[_("li",[v._v("全量 vs 增量")]),v._v(" "),_("li",[v._v("同步 vs 异步")]),v._v(" "),_("li",[v._v("实时 vs 缓存")]),v._v(" "),_("li",[v._v("原片 vs 压缩")])]),v._v(" "),_("p",[v._v("全量 vs 增量，是指页面加载特别是列表页加载数据慢的情况，要从数据加载是全量还是增量的角度去诊断问题。")]),v._v(" "),_("p",[v._v("以京东 App 列表页为例，首屏一般展示 4 条左右的商品数据，PC 页首屏展示 50 条商品数据，后端数据接口一般是同一套（无论是针对移动端还是 PC 端），这时 App 列表页请求后端接口，后端一次返回 50 条数据就不合适了。更好的做法是，分接口先拉取首屏所需的 4 条数据，然后在页面滚动或者下拉操作加载后续数据即可。")]),v._v(" "),_("p",[v._v("值得注意的是，为了保持体验流畅，有时候我们会多加载几条，比如开始加载 6 条，刚开始滚动到首屏结束时，第 5 条数据已经有了（此时请求第 7 条数据），不需要等后端服务器返回就可以展示。")]),v._v(" "),_("p",[v._v("同步 vs 异步，是指遇到页面加载时间过长的情形，是否因为接口同步加载导致的问题。此时可以用异步的思路去解决。比如电商 App 列表页，一般需要先去拉取导航位置图片和链接信息，然后去拉取商品列表信息，这会延长加载时间。此时我们可以考虑同时拉取两个列表，中间有依赖关系的地方，集中到第一个接口中去获取，然后就可以并行去请求两个接口了。")]),v._v(" "),_("p",[v._v("实时 vs 缓存，是指遇到接口数据或者静态资源加载过长时候，要看一下是否是因为使用了实时数据的角度导致的，是否可以缓存策略来解决问题。")]),v._v(" "),_("p",[v._v("具体来说，如果是能够缓存的数据（如双 11 的榜单、页面中的 JS、CSS 资源），建议优先检查一下是否做了缓存处理；如果用的是实时数据（如商品实时的价格，库存实时的情况），要看一下是否会导致性能瓶颈。在不影响用户体验的前提下，还可以看看某些数据是不是可以定时去更新，如用户购买榜单信息等。")]),v._v(" "),_("p",[v._v("有关静态资源（如 JS、CSS文件）缓存处理，比较好的方法是，将每次渲染后的页面做缓存，页面打开时就展示，然后局部细微做更新，确保用户体验更好。")]),v._v(" "),_("p",[v._v("原片 vs 压缩， 是指当遇到图片加载缓慢的问题，可以查看下图片是否是原图。如果是，可以做一些无损或者有损压缩处理，以此提高加载速度，或者尽量不使用原始图片（如 png-24），优先使用 webp 等图片格式。")]),v._v(" "),_("p",[v._v("为了提高性能，页面在展示时，可以先设置成展示一张低质量的图片，遇到许多用户特别关注这张图片时，再做进一步的优化处理也不迟。具体的优化手段我会在后续章节里面提到。")]),v._v(" "),_("h2",{attrs:{id:"效果评估"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#效果评估"}},[v._v("#")]),v._v(" 效果评估")]),v._v(" "),_("p",[v._v("假设我们经过问题诊断，也进行了优化，那么我们做完一个性能优化项目之后，如何评估项目效果呢？如果仅仅给出项目的性能指标变化，比如做完移动 M 站性能优化后，首屏时间提升 30%，并不足以触达业务同学的内心。")]),v._v(" "),_("p",[v._v("最好的方式就是通过性能优化，提高业务数据指标。 以电商 App 为例，最关注的一个指标是从访问用户到订单的转化（比如 100 个用户成了 3 单，转化率为 3%）。那么，性能指标和转化率指标有什么关系呢？")]),v._v(" "),_("p",[v._v("根据 skilled.co 的数据表示，沃尔玛在线网站页面加载时间每减少一秒，转化率增加 2%。我之前的移动端 M 站性能优化项目也验证过这一点，当时性能有了 30% 的提升，列表页到详情页的转化提高了 10%。当然，这里面有一个隐含假设，当前页面的首屏时间远大于 1s（如 2s ～ 5s），如果首屏已经秒开，提升将非常有限。")]),v._v(" "),_("p",[v._v("具体怎么评估转化率指标？我们需要用优化前后两个版本对比的方式，去看转化率指标的变化，也就是你经常听到的AB 测试。")]),v._v(" "),_("p",[v._v("具体怎么做呢？我以列表页性能优化项目为例，在做性能优化之前，先把列表页面分成 A、B 两个版本，这两个版本可以通过条件语句区分代码块，还可以通过模板和路由的方式来区分。其中，A 版本是筛选项优化前的，B 版本是筛选项化后的。此处我们选择用IF条件语句在列表页代码里面做区分，如果当前需要展示版本A，URL 参数中传入 version = A。")]),v._v(" "),_("p",[v._v("然后当用户到了列表页加入购物车下单时，我们用代码在提交给购物车的订单上做一个标记（from=version）。这样交易成功后，通过统计埋点就可以统计到 A、B 版本各自对应的订单转化率。转化率的变化就是列表页性能优化项目的优化数据。")]),v._v(" "),_("p",[v._v("这里需要注意一点，为了确保同一个版本波动率很小，在做对比之前还要先对列表页做 AA 测试，也就是两个版本代码完全一样的测试。当它们的差异基本上万分之一以下了再去做 AB 测试。")]),v._v(" "),_("p",[v._v("小结\n"),_("img",{attrs:{src:"/performance/platform_6.png",alt:"小结"}})])])}),[],!1,null,null,null);_.default=e.exports}}]);