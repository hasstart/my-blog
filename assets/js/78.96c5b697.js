(window.webpackJsonp=window.webpackJsonp||[]).push([[78],{407:function(s,t,a){"use strict";a.r(t);var e=a(4),n=Object(e.a)({},(function(){var s=this,t=s._self._c;return t("ContentSlotsDistributor",{attrs:{"slot-key":s.$parent.slotKey}},[t("h2",{attrs:{id:"前言"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#前言"}},[s._v("#")]),s._v(" 前言")]),s._v(" "),t("p",[s._v("因为 Hybrid 开发模式借助 WebView，把 Native 和 H5 的各自优势进行了结合。具体来说，它既具备 Native 体验好、操作硬件能力强、代码安全等优势，又具备了 H5 发版节奏快、Web 标准开发效率高等优势。")]),s._v(" "),t("p",[s._v("通过它，前端工程师几分钟内就能完成需求上线，不用等 App一周的发版周期，不用等待审核。除此之外，使用 Hybrid 开发模式还可以将一个大的横向需求，切分到各个业务前端团队并行工作，大大提升了需求吞吐率和迭代速度。如今，许多 App，如美团、去哪儿、淘宝都在使用 Hybrid 开发模式。")]),s._v(" "),t("p",[s._v("不过它的缺点也明显，比如加载性能问题、白屏问题、界面展示和操作的局限性，无法使用系统功能等等。")]),s._v(" "),t("p",[s._v("H5 是 Hybrid App当中的一个核心，它可以通过 SDK 访问 App 底层系统，让前端页面获取调用传感器、存储、日历/联系人等原生能力。一般 H5 加载大致流程如下：")]),s._v(" "),t("p",[s._v("进入 App → 初始化 WebView → 客户端发起请求 → 下载HTML 及 JS/CSS 资源 → 解析JS执行 → JS 请求数据→服务端处理并返回数据 → 客户端解析 DOM 并渲染 → 下载渲染图片 → 完成整体渲染。")]),s._v(" "),t("p",[s._v("从大的时间节点来看，初始化 WebView 之前都算是 App 启动阶段，从初始化 WebView 到客户端解析 Dom 并渲染，属于白屏时间，剩下的环节就是整体渲染后首屏结束，我们把这段称为页面首屏渲染阶段。")]),s._v(" "),t("p",[s._v("所以，接下来我就以这三个阶段——App 启动、页面白屏、页面首屏渲染来介绍下相关的优化方案。")]),s._v(" "),t("h2",{attrs:{id:"app启动阶段的优化方案"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#app启动阶段的优化方案"}},[s._v("#")]),s._v(" App启动阶段的优化方案")]),s._v(" "),t("p",[s._v("App 启动，尤其是冷启动（首次启动 App）时，并不会直接初始化 WebView，而是在创建 WebView 实例时，才会创建它的基础框架。系统打开 WebView 时，也不是直接建立连接发起请求，而是又一个启动浏览器内核的过程。")]),s._v(" "),t("p",[s._v("那么这中间大致需要多长时间呢？我们在一次二手业务列表页测试时发现，首次启动 WebView 平均需要 400ms 左右，二次启动平均有 220ms。按照页面秒开的目标，WebView 启动就占了 40% 的时间，所以我们要想办法来优化它。")]),s._v(" "),t("p",[s._v("对此，我建议使用 WebView 全局的优化方式，即在 App 启动时启动一个 WebView 后让其全局化。或者更彻底一点，把 Webview 的实例保存在一个公共池中，当用户访问这个 WebView 时，直接从公共池取来加载网页，而不是重新初始化一个新的 WebView。")]),s._v(" "),t("p",[s._v("通过这个办法，可以大大减少后续 WebView 在 App 中打开的时间。以我的一个优化实践经验（房产列表页）为例，可以减少 200ms 左右的启动时间。")]),s._v(" "),t("h2",{attrs:{id:"页面白屏阶段的优化方案"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#页面白屏阶段的优化方案"}},[s._v("#")]),s._v(" 页面白屏阶段的优化方案")]),s._v(" "),t("p",[s._v("在页面白屏阶段，也就是 H5 页面加载的下载HTML及JS/CSS资源环节当中，会有哪些情况影响性能，以及会用到哪些优化方案呢？")]),s._v(" "),t("p",[s._v("一般情况下，前端工程师将静态资源上线到 CDN 上后， WebView 会发起网络请求去获取。当用户在弱网或者网络比较差的环境下，页面白屏时间会特别长。此时，如果我们能将静态资源提前下载到本地，WebView 获取静态资源时就可以直接从本地获取，这样会大幅降低白屏时间，这就是离线包的作用。")]),s._v(" "),t("p",[s._v("所谓离线包，就是将包括 HTML、JavaScript、CSS 等页面内静态资源打包到一个压缩包内，App 预先内置该压缩包到本地，然后当用户在客户端打开 H5 页面时，直接从本地加载就行了。这样无须再向服务器端请求，最大程度地摆脱网络环境对 H5 页面的影响。")]),s._v(" "),t("p",[s._v("如果离线包是提前下载到本地，那么更新问题怎么解决呢？比如一个业务的静态资源更新了，我们该怎么保证用户请求到的离线包资源也是最新的呢？")]),s._v(" "),t("p",[s._v("我们可以在生成离线包的同时，生成一个配置文件，让App 先根据这个静态文件判断是需要更新离线包，还是直接向业务服务器进行请求。")]),s._v(" "),t("p",[s._v("但如果静态资源本地版本实在太老，此时客户端将直接向服务器端请求资源（如离线包无法命中的情况），这该怎么办呢？它的优化方案就是骨架屏——我们可以给客户一个心理预期，在接口请求和渲染过程中，让他知道接下来要渐进式展示的内容和结构是什么。")]),s._v(" "),t("p",[s._v("虽然说骨架屏可以“加快”过程中的等待时间，但请注意，这个加快只是视觉和心理上的效果，实质上等待时间还是那么多。那有没有办法减少最后的渲染时间呢？我们可以使用 SSR 来优化。")]),s._v(" "),t("p",[s._v("SSR （Server Side Rendering，服务端渲染）是指客户端发起页面请求后，服务端直接将组件和页面内容渲染成 DOM 结构，返回给客户端。你可以通过 Chrome 的调试工具 DevTools 打开页面后，看到相关的源文件内容。")]),s._v(" "),t("p",[s._v("提到 SSR ，就不得不提下 CSR（Client Side Rendering）。目前许多人在移动端上还在使用 CSR，但其实在 CSR 方案下，它的页面资源请求和数据渲染流程相当烦琐冗长。")]),s._v(" "),t("p",[s._v("具体来说，在 CSR 方案中，HTML 文件仅作为入口，客户端在请求时，服务端不做任何处理，只返回一个 index.html 文件，然后客户端根据页面上的 JS 脚本去请求内容，生成 DOM 添加到 HTML 页面中，形成最终的内容。我以一个图为例，你可以看出同一个页面在不同技术方案下面白屏方面的差异。")]),s._v(" "),t("p",[t("img",{attrs:{src:"/performance/platform_12.png",alt:"小结"}})]),s._v(" "),t("p",[s._v("从图中可以看到，在 SSR 下第三帧就可以看到内容，而在 CSR 下需要第六帧才能看到。")]),s._v(" "),t("h2",{attrs:{id:"首屏渲染阶段的优化方案"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#首屏渲染阶段的优化方案"}},[s._v("#")]),s._v(" 首屏渲染阶段的优化方案")]),s._v(" "),t("p",[s._v("处理完静态资源后，马上进入服务端处理和返回数据请求过程，这就是首屏渲染阶段。这阶段要解决的主要问题是怎样减少数据接口加载的时间。")]),s._v(" "),t("p",[s._v("有什么优化方案呢？")]),s._v(" "),t("p",[s._v("一方面，我们可以通过服务端优化来降低后端接口的响应时间，比如从 200ms 降低到 100ms。但优化到 100ms 之后，其优化空间就非常有限了。另一方面，可以从接口和页面并行加载的角度去做优化加载时间，也就是接口预加载。它有以下几种形式。")]),s._v(" "),t("p",[s._v("第一种，通过客户端代理数据接口请求，在客户端初始化 WebView 的同时，直接由 Native 发起网络请求，H5 页面初始化完成后（对于 CSR 页面，也就是 index.html 加载完成后）直接通过 SDK 向 Native 获取数据。")]),s._v(" "),t("p",[s._v("第二种，根据业务场景选择预加载。举个例子，我们在滚动下拉列表的页面，根据用户滚动条的位置，提前加载一页的展示数据，这样用户在滚动下拉时，不会有停滞的感觉，非常流畅。")]),s._v(" "),t("p",[s._v("第三种，在一些旅行类 App上，用户在订酒店的时候，当他进行了目的地和日期选择操作后，将结果上传服务端后，服务端会根据用户的操作路径，判断打开搜索结果页的概率。如果概率超过某一个值，就会启动搜索结果页的数据获取，这样在进入搜索结果页后，已经有了接口数据，大大节省了时间。")]),s._v(" "),t("p",[s._v("小结\n"),t("img",{attrs:{src:"/performance/platform_13.png",alt:"小结"}})]),s._v(" "),t("p",[s._v("好了，我们以 App H5 的加载流程，介绍了 Hybrid 下的整体优化方案。除了以上所讲的，在实际过程中还有不少注意事项。")]),s._v(" "),t("p",[s._v("离线包命中率的统计，因为离线包即便不命中也不影响页面效果，所以出现问题很难发现，为此，在业务上线的日常运行中要对命中率进行统计。")]),s._v(" "),t("p",[s._v("WebView 的优化，全局 WebView Pool 时一定要注意及时销毁，不然对 App 资源的占用会比较大。")]),s._v(" "),t("p",[s._v("很多公司在预加载数据的基础上发展出了预渲染，但在实施过程中我们发现，它对 App 内存占用过大。")]),s._v(" "),t("h2",{attrs:{id:"离线包"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#离线包"}},[s._v("#")]),s._v(" 离线包")]),s._v(" "),t("p",[s._v("我们先看一下离线包的整体实现方案。")]),s._v(" "),t("p",[t("img",{attrs:{src:"/performance/app-1.png",alt:"整体实现方案"}})]),s._v(" "),t("p",[s._v("上图左边是各模块对应的角色，有 FE 工程师（也就是前端工程师）、Admin、用户，右边是具体做的事情。")]),s._v(" "),t("p",[s._v("具体来说，离线包的前端源码主要包括 HTML、SCSS、Img 等内容，FE 工程师在需求开发过程中，先从 GitLab 中下载前端工程到本地，通过 CI/CD 将离线包版本上线。接下来，为了便于管理这个离线包，我们需要开发一个它的管理后台，使用的技术包括 Egg 框架和 MongoDB。")]),s._v(" "),t("p",[s._v("最后，我们将离线包存储在 CDN 上，当用户进入 App 向服务器发起静态资源请求时，客户端会拦截下来并根据内置离线配置，请求离线包管理后台。离线包管理后台返回结果，客户端决定是直接使用全量包，还是请求差分包。当这部分工作完成后，客户端将请求代理到它内置的离线资源中，返回给用户页面内容。")]),s._v(" "),t("p",[s._v("整个过程包含"),t("strong",[s._v("离线包生成、离线包管理后台、离线包部署及优化")]),s._v("三部分。接下来我就详细介绍下。")]),s._v(" "),t("h3",{attrs:{id:"离线包生成"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#离线包生成"}},[s._v("#")]),s._v(" 离线包生成")]),s._v(" "),t("p",[s._v("如何生成离线包呢？我们可以把需要离线的资源，如首页要用到的 JS、CSS 和图片，通过 webpack 插件（"),t("code",[s._v("ak-webpack-plugin")]),s._v("，腾讯 Alloy 团队出品）打包生成压缩包。这个过程大致分为三步。")]),s._v(" "),t("p",[s._v("第一步，将前端项目从 Git 仓库中 clone 出来，然后打出一个 offline 分支。")]),s._v(" "),t("p",[s._v("第二步，拷贝离线包专用的 webpack 配置文件到项目中，我们在此开源项目的基础上做了一些修改。比如，修改对应的 package.json 文件，这样在本地测试时可以直接将离线包拷贝到测试机上，以方便进行测试。")]),s._v(" "),t("div",{staticClass:"language-js line-numbers-mode"},[t("pre",{pre:!0,attrs:{class:"language-js"}},[t("code",[s._v("  "),t("span",{pre:!0,attrs:{class:"token string-property property"}},[s._v('"builduploadtest"')]),t("span",{pre:!0,attrs:{class:"token operator"}},[s._v(":")]),s._v(" "),t("span",{pre:!0,attrs:{class:"token string"}},[s._v('"node build/uploadtest.js"')]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(",")]),s._v("\n  "),t("span",{pre:!0,attrs:{class:"token string-property property"}},[s._v('"buildupload"')]),t("span",{pre:!0,attrs:{class:"token operator"}},[s._v(":")]),s._v(' "node build'),t("span",{pre:!0,attrs:{class:"token operator"}},[s._v("/")]),s._v("upload"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(".")]),s._v("js”"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(",")]),s._v("\n")])]),s._v(" "),t("div",{staticClass:"line-numbers-wrapper"},[t("span",{staticClass:"line-number"},[s._v("1")]),t("br"),t("span",{staticClass:"line-number"},[s._v("2")]),t("br")])]),t("p",[s._v("第三步，通过 npm i 安装所需的包，并执行命令 npm run build 查看效果，然后同步修改config/offline.js 中的对象 URL 为页面真实 URL，修改导出静态资源的路径为真实的 CDN 资源路径。这一步决定了离线包的资源对应关系，如果出问题，线上会出现 404 ，所以千万要注意。")]),s._v(" "),t("p",[s._v("下方代码中 offlinepath 对应的就是你需要拦截的静态资源路径，拦截这个路径后， 客户端从对应本地的离线包中加载资源。示例代码如下：")]),s._v(" "),t("div",{staticClass:"language-json line-numbers-mode"},[t("pre",{pre:!0,attrs:{class:"language-json"}},[t("code",[s._v("  "),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("{")]),s._v("\n    "),t("span",{pre:!0,attrs:{class:"token property"}},[s._v('"bizid"')]),t("span",{pre:!0,attrs:{class:"token operator"}},[s._v(":")]),s._v(" "),t("span",{pre:!0,attrs:{class:"token number"}},[s._v("13")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(",")]),s._v("\n    "),t("span",{pre:!0,attrs:{class:"token property"}},[s._v('"date"')]),t("span",{pre:!0,attrs:{class:"token operator"}},[s._v(":")]),s._v(" "),t("span",{pre:!0,attrs:{class:"token string"}},[s._v('"1513681326579"')]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(",")]),s._v("\n    "),t("span",{pre:!0,attrs:{class:"token property"}},[s._v('"ver"')]),t("span",{pre:!0,attrs:{class:"token operator"}},[s._v(":")]),s._v(" "),t("span",{pre:!0,attrs:{class:"token string"}},[s._v('"20171219185710"')]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(",")]),s._v("\n    "),t("span",{pre:!0,attrs:{class:"token property"}},[s._v('"offlinePath"')]),t("span",{pre:!0,attrs:{class:"token operator"}},[s._v(":")]),s._v(" "),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("[")]),s._v("\n                      "),t("span",{pre:!0,attrs:{class:"token string"}},[s._v('"c.58cdn.com.cn/youpin/activities"')]),s._v("\n                  "),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("]")]),s._v("\n  "),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("}")]),s._v("\n")])]),s._v(" "),t("div",{staticClass:"line-numbers-wrapper"},[t("span",{staticClass:"line-number"},[s._v("1")]),t("br"),t("span",{staticClass:"line-number"},[s._v("2")]),t("br"),t("span",{staticClass:"line-number"},[s._v("3")]),t("br"),t("span",{staticClass:"line-number"},[s._v("4")]),t("br"),t("span",{staticClass:"line-number"},[s._v("5")]),t("br"),t("span",{staticClass:"line-number"},[s._v("6")]),t("br"),t("span",{staticClass:"line-number"},[s._v("7")]),t("br"),t("span",{staticClass:"line-number"},[s._v("8")]),t("br")])]),t("p",[s._v("从中你可以看到，线上资源路径和离线包资源路径映射对应，我们设计时把 URL path 转换成了本地的文件目录，可以让客户端代理时规则解析更简单。")]),s._v(" "),t("div",{staticClass:"language-js line-numbers-mode"},[t("pre",{pre:!0,attrs:{class:"language-js"}},[t("code",[s._v("  offline\n  "),t("span",{pre:!0,attrs:{class:"token operator"}},[s._v("|")]),t("span",{pre:!0,attrs:{class:"token operator"}},[s._v("--")]),s._v(" c"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(".")]),s._v("58cdn"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(".")]),s._v("com"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(".")]),s._v("cn\n  "),t("span",{pre:!0,attrs:{class:"token operator"}},[s._v("|")]),s._v("    "),t("span",{pre:!0,attrs:{class:"token operator"}},[s._v("|")]),t("span",{pre:!0,attrs:{class:"token operator"}},[s._v("--")]),s._v(" youpin\n  "),t("span",{pre:!0,attrs:{class:"token operator"}},[s._v("|")]),s._v("         "),t("span",{pre:!0,attrs:{class:"token operator"}},[s._v("|")]),t("span",{pre:!0,attrs:{class:"token operator"}},[s._v("--")]),s._v(" activities\n  "),t("span",{pre:!0,attrs:{class:"token operator"}},[s._v("|")]),s._v("              "),t("span",{pre:!0,attrs:{class:"token operator"}},[s._v("|")]),t("span",{pre:!0,attrs:{class:"token operator"}},[s._v("--")]),s._v(" index"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(".")]),s._v("html\n  "),t("span",{pre:!0,attrs:{class:"token operator"}},[s._v("|")]),s._v("              "),t("span",{pre:!0,attrs:{class:"token operator"}},[s._v("|")]),t("span",{pre:!0,attrs:{class:"token operator"}},[s._v("--")]),s._v(" js\n  "),t("span",{pre:!0,attrs:{class:"token operator"}},[s._v("|")]),s._v("                  "),t("span",{pre:!0,attrs:{class:"token operator"}},[s._v("|")]),t("span",{pre:!0,attrs:{class:"token operator"}},[s._v("--")]),s._v(" index"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(".")]),s._v("js\n")])]),s._v(" "),t("div",{staticClass:"line-numbers-wrapper"},[t("span",{staticClass:"line-number"},[s._v("1")]),t("br"),t("span",{staticClass:"line-number"},[s._v("2")]),t("br"),t("span",{staticClass:"line-number"},[s._v("3")]),t("br"),t("span",{staticClass:"line-number"},[s._v("4")]),t("br"),t("span",{staticClass:"line-number"},[s._v("5")]),t("br"),t("span",{staticClass:"line-number"},[s._v("6")]),t("br"),t("span",{staticClass:"line-number"},[s._v("7")]),t("br")])]),t("p",[s._v("在这过程中，我们不需要关注资源之间加载的依赖关系，比如首页资源依赖，也不需要关注具体的业务逻辑是列表页还是详情页，只需要关注 webpack 最终构建出的内容结构即可。")]),s._v(" "),t("p",[s._v("另外，如果一些资源不需要走离线包，比如非首屏的图片资源，可以选择 webpack 排除的方式设置。做完这些操作后，我们可以将离线包功能封装进脚手架里，这样在初始化一个项目时就可以直接接入离线包。")]),s._v(" "),t("p",[s._v("前面提到过，离线包是下载本地之后生成的，那如何保证离线包的内容是最新的呢？这就要用到离线包管理后台了。")]),s._v(" "),t("h3",{attrs:{id:"离线包管理后台"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#离线包管理后台"}},[s._v("#")]),s._v(" 离线包管理后台")]),s._v(" "),t("p",[s._v("离线包管理后台主要是提供离线包监控及配置管理的平台，我们可以通过它查看某条业务的离线包使用情况，比如是否在使用，离线包版本是多少，启用时间多长等等。除此之外，还可以通过它开启和关闭离线包。")]),s._v(" "),t("p",[s._v("那这个离线包管理后台怎么搭建呢？")]),s._v(" "),t("p",[s._v("首先要注意的是，管理后台的技术栈选型最好和性能平台保持一致，这样可以尽最大程度与性能平台相互复用组件和页面模板。具体的选型，我使用 React 技术栈进行开发，模板使用 Ant design，服务端采用 Node.js 的方案，后台存储采用 MongoDB 来实现。在这个后台上，主要通过三个核心页面——全局页、离线包列表页、详情页来完成对离线包的管理功能。")]),s._v(" "),t("p",[s._v("首先是"),t("strong",[s._v("全局页")]),s._v("，它提供离线包管理功能，可以开启和关闭离线包。由于这个开启和关闭是针对所有离线包的，所以它的权限设置要高一些，防止误操作带来的线上问题。")]),s._v(" "),t("p",[s._v("其次是"),t("strong",[s._v("离线包列表页")]),s._v("，主要是对所有的离线包资源进行展示和操作。这个列表页包括展示业务名称、版本号、包类型、发布时间、在线情况。此外这个列表页上还有可以点击在线和离线的按钮，方便离线包上下线操作，以及进入详情页的链接。")]),s._v(" "),t("p",[s._v("离线包列表页里包类型是我们实现的一个大亮点，离线包的类型一般包括差分和全量包，我们可以通过它们大大减少用户的流量使用，降低下载离线包的时间。")]),s._v(" "),t("p",[s._v("具体来说，在 App 里面，我们会先内置一份全量包作为基线版本。但如果我们判断当前版本不是最新的话，一种做法就是下载一个全新的版本，第二种做法是下载一个差分包的版本，第三种做法是直接绕过离线包，请求线上接口。")]),s._v(" "),t("p",[s._v("显然第三种最不可取，它等于没有了离线包优化的效果，第二种呢，全量包体积都比较大，以我们公司业务为例，将近 600K 的大小，而如果用差分包，平均 200K 左右的大小，并不影响性能。")]),s._v(" "),t("p",[s._v("那怎么实现差分包呢？这就需要用到 BSDP 了——一个基于二进制 diff 的 Node 工具包。它有两个核心模块：bsdiff 和 bspatch。")]),s._v(" "),t("p",[s._v("其中 bsdiff 是个库函数，用于对源文件和目标文件求 diff，生成差分包。当我们要升级离线包版本（比如升级首页金刚位功能），就可以使用它来发布一个差分包，放在 CDN 上 ，同时生成配置文件，如 2021030701 放到管理配置后台上。这样客户端请求静态资源之前，先查看本地配置文件，发现配置文件是 2021030606 版本的，就直接去请求对应的差分包。而 bspatch 主要是用来根据差分包的内容，合并本地版本成一个新的全量包。")]),s._v(" "),t("p",[s._v("最后是"),t("strong",[s._v("详情页")]),s._v("。详情页主要是方便我们查看下载离线包检查内容是否正确，以及设置业务优先级。为什么要设置业务优先级呢？")]),s._v(" "),t("p",[s._v("因为随着业务规模的扩大，每条业务都想使用离线包来提升页面性能，离线包体积就越来越大，这时候必须得设置优先级，给流量大的业务优先使用离线包，其他业务暂停使用。我们现在仅针对金刚位（ App 首页核心导航位）提供离线包功能。")]),s._v(" "),t("p",[s._v("离线包部署及优化\n离线包的部署流程见下图：")]),s._v(" "),t("p",[t("img",{attrs:{src:"/performance/app-2.png",alt:"离线包部署及优化"}})]),s._v(" "),t("p",[s._v("前端工程师也就是图中的 FE，将前端工程打包，生成离线包的入口页面 index_sonic.html （支持离线包的index.html），然后通过前端的静态资源发布系统（我们公司使用的是 beetle，类似jerkens 上线，增加了 web 界面）上线到 CDN。")]),s._v(" "),t("p",[s._v("接下来，FE 将静态资源（如 index.js、home.css、banner.jpg）打包成全量离线包到 CDN，然后同步增加离线管理后台的配置，离线管理后台会根据基础包生成差分包上传到 CDN。")]),s._v(" "),t("p",[s._v("这就是整体的部署流程。如果离线包功能异常（如出现无法访问），该怎么快速解决？")]),s._v(" "),t("p",[s._v("我建议一定要做好离线包的开关功能。在出现问题时，通过在离线包后台操作，及时关掉离线包功能，就可以及时确保用户功能恢复正常。")]),s._v(" "),t("p",[s._v("比如，我们在某一次详情页升级项目中，发现用户客户端在下载离线包时出现网络问题，导致无法解压，进而页面内容无法展示，当时我们的做法就是立即关闭离线包功能，保证了用户正常访问。")]),s._v(" "),t("p",[s._v("小结\n"),t("img",{attrs:{src:"/performance/app-3.png",alt:"小结"}})]),s._v(" "),t("p",[s._v("好了，以上就是离线包的实现方案，这里面有两个注意事项。")]),s._v(" "),t("p",[s._v("第一，在 iOS 系统，我们经常会用到 WKWebView ，此时如果要实现离线包，必须解决 WKWebView 下面的请求拦截难题，这时可以借助私有 API 方案来实现。")]),s._v(" "),t("p",[s._v("第二，问题的诊断定位流程和原来不一样了。平常的定位问题只需要抓包，查看 source 即可，而在离线包的问题诊断，需要我们先抓包getofflineconfig 接口，找到对应的 bid，然后根据 bid 找到正确的配置项，点击配置项进入详情下载离线包，最后解压离线包确认代码是否正确。")]),s._v(" "),t("h2",{attrs:{id:"使用骨架屏方案优化页面性能"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#使用骨架屏方案优化页面性能"}},[s._v("#")]),s._v(" 使用骨架屏方案优化页面性能")]),s._v(" "),t("h3",{attrs:{id:"图片骨架屏的实现"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#图片骨架屏的实现"}},[s._v("#")]),s._v(" 图片骨架屏的实现")]),s._v(" "),t("p",[s._v("想要了解如何实现，我们先来看一下图片骨架屏的加载流程。在 App 业务功能设计时，设计师会针对这个页面制作一张离线包的图片，在 WebView 启动时，客户端把这张图片覆盖在页面上，页面开始进入请求资源的流程。当页面 WebView 加载完成或者前端页面通知客户端加载完成时，客户端通过渐变动画隐藏这张图片，将准备好的页面展现给用户。")]),s._v(" "),t("p",[s._v("所以，如果想要实现骨架屏，大致有这么几步。")]),s._v(" "),t("p",[s._v("第一步：先让 UI 设计师设计一张当前页面对应离线包的图，作为骨架屏展示图片。")]),s._v(" "),t("p",[s._v("第二步，在业务需求开发过程中，前端工程师拿到图后，把这张图片上传到 CDN 上面。")]),s._v(" "),t("p",[s._v("第三步，在客户端代码，增加启动时读取图片骨架屏的配置文件。如下面代码所示。")]),s._v(" "),t("div",{staticClass:"language-js line-numbers-mode"},[t("pre",{pre:!0,attrs:{class:"language-js"}},[t("code",[s._v("  "),t("span",{pre:!0,attrs:{class:"token comment"}},[s._v("// 传入设备分辨率ratioWidth:400, ratioHeight:500")]),s._v("\n  "),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("{")]),s._v("\n  "),t("span",{pre:!0,attrs:{class:"token string-property property"}},[s._v('"code"')]),t("span",{pre:!0,attrs:{class:"token operator"}},[s._v(":")]),t("span",{pre:!0,attrs:{class:"token number"}},[s._v("0")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(",")]),s._v("\n  "),t("span",{pre:!0,attrs:{class:"token comment"}},[s._v("// code 是0 代表请求成功   -1 代表图片骨架屏功能关闭")]),s._v("\n  "),t("span",{pre:!0,attrs:{class:"token string-property property"}},[s._v('"data"')]),t("span",{pre:!0,attrs:{class:"token operator"}},[s._v(":")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("{")]),s._v("\n      "),t("span",{pre:!0,attrs:{class:"token string-property property"}},[s._v('"m.58.com/enjoy-given/eg/index.html"')]),t("span",{pre:!0,attrs:{class:"token operator"}},[s._v(":")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("{")]),s._v("\n        "),t("span",{pre:!0,attrs:{class:"token string-property property"}},[s._v('"rege"')]),t("span",{pre:!0,attrs:{class:"token operator"}},[s._v(":")]),t("span",{pre:!0,attrs:{class:"token string"}},[s._v("'#/content/index'")]),s._v("\n        "),t("span",{pre:!0,attrs:{class:"token string-property property"}},[s._v('"routes"')]),t("span",{pre:!0,attrs:{class:"token operator"}},[s._v(":")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("{")]),s._v("\n            "),t("span",{pre:!0,attrs:{class:"token string-property property"}},[s._v('"#/content/index"')]),t("span",{pre:!0,attrs:{class:"token operator"}},[s._v(":")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("{")]),s._v("\n              "),t("span",{pre:!0,attrs:{class:"token string-property property"}},[s._v('"downloadUrl"')]),t("span",{pre:!0,attrs:{class:"token operator"}},[s._v(":")]),t("span",{pre:!0,attrs:{class:"token string"}},[s._v("'https://m.58.com/pic.png?400*500'")]),s._v("\n              "),t("span",{pre:!0,attrs:{class:"token string-property property"}},[s._v('"imgName"')]),t("span",{pre:!0,attrs:{class:"token operator"}},[s._v(":")]),t("span",{pre:!0,attrs:{class:"token string"}},[s._v("'pic.png'")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(",")]),s._v("\n              "),t("span",{pre:!0,attrs:{class:"token string-property property"}},[s._v('"id"')]),t("span",{pre:!0,attrs:{class:"token operator"}},[s._v(":")]),t("span",{pre:!0,attrs:{class:"token string"}},[s._v("'10001'")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(",")]),s._v("\n        "),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("}")]),s._v("\n      "),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("}")]),s._v("\n    "),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("}")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(",")]),s._v("\n  "),t("span",{pre:!0,attrs:{class:"token string-property property"}},[s._v('"msg"')]),t("span",{pre:!0,attrs:{class:"token operator"}},[s._v(":")]),t("span",{pre:!0,attrs:{class:"token string"}},[s._v('""')]),s._v("\n\n    "),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("}")]),s._v("\n\n  "),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("}")]),s._v("\n")])]),s._v(" "),t("div",{staticClass:"line-numbers-wrapper"},[t("span",{staticClass:"line-number"},[s._v("1")]),t("br"),t("span",{staticClass:"line-number"},[s._v("2")]),t("br"),t("span",{staticClass:"line-number"},[s._v("3")]),t("br"),t("span",{staticClass:"line-number"},[s._v("4")]),t("br"),t("span",{staticClass:"line-number"},[s._v("5")]),t("br"),t("span",{staticClass:"line-number"},[s._v("6")]),t("br"),t("span",{staticClass:"line-number"},[s._v("7")]),t("br"),t("span",{staticClass:"line-number"},[s._v("8")]),t("br"),t("span",{staticClass:"line-number"},[s._v("9")]),t("br"),t("span",{staticClass:"line-number"},[s._v("10")]),t("br"),t("span",{staticClass:"line-number"},[s._v("11")]),t("br"),t("span",{staticClass:"line-number"},[s._v("12")]),t("br"),t("span",{staticClass:"line-number"},[s._v("13")]),t("br"),t("span",{staticClass:"line-number"},[s._v("14")]),t("br"),t("span",{staticClass:"line-number"},[s._v("15")]),t("br"),t("span",{staticClass:"line-number"},[s._v("16")]),t("br"),t("span",{staticClass:"line-number"},[s._v("17")]),t("br"),t("span",{staticClass:"line-number"},[s._v("18")]),t("br"),t("span",{staticClass:"line-number"},[s._v("19")]),t("br"),t("span",{staticClass:"line-number"},[s._v("20")]),t("br")])]),t("p",[s._v("首先是传入设备分辨率，比如 400 * 500，然后设置状态码 code。code 是 0 代表成功，-1 代表关闭图片骨架屏功能。 data 对象是具体的数据，"),t("code",[s._v("m.58.com/enjoy-given/eg/index.html")]),s._v(" 是对应的页面 URL，骨架屏那个图片的地址是"),t("code",[s._v("https://m.58.com/pic.png?400*500")]),s._v("。")]),s._v(" "),t("p",[s._v("当用户打开 WebView 时，客户端对 URL 进行解析，取得该 URL 对应的 host 和pathname，然后将这两个数据分别与 data 和 routes 中的数据做比较。")]),s._v(" "),t("p",[s._v("如果都匹配上，说明要展示骨架屏，此时可根据 routes下面的 id 和 imgName 获取到对应的图片文件。当三个字符串拼起来，即zzSkeleton + id +imgName，就可获得最终的图片名字。其中 zzSkeleton 就是一个字符串， ID 我设置成 10001，imgName 表示具体的图片名称，比如代码中的 pic.png，最终图片名称为 “zzSkeleton10001pic.pn”。")]),s._v(" "),t("p",[s._v("在实现过程中要注意以下三点。")]),s._v(" "),t("p",[s._v("第一，注意区分首次使用和二次使用。首次使用的话，客户端遍历上述配置文件，下载数据中对应图片即可；二次使用时，需要拿当前的配置文件对比之前的配置文件，如果图片名称不同，需要下载新的图片。")]),s._v(" "),t("p",[s._v("第二，需要客户端在内存中建立图片，以加快图片骨架屏的加载速度。")]),s._v(" "),t("p",[s._v("第三，图片骨架屏展示过程中会出现拉伸问题。这是因为分辨率不同造成的，我们可以让 App")]),s._v(" "),t("p",[s._v("在获取配置文件时，加上当前页面的分辨率，这样接口会根据分辨率返回最合适的图片。")]),s._v(" "),t("p",[s._v("以上是具体的实现方案，在实际当中，我们该如何借助它来进行性能优化呢？")]),s._v(" "),t("p",[s._v("使用及注意事项")]),s._v(" "),t("p",[s._v("首先骨架屏方案，非常适合资源加载时间长的页面，比如列表页的首屏内容有很多个数据接口、筛选项、精选数据、列表数据等，这时候一定要用骨架屏。而对于一些 SSR 页面，因为白屏阶段比较短，可用可不用。")]),s._v(" "),t("p",[s._v("骨架屏使用起来比较简单，前端工程师只要在开发项目时，让 UI 对应出一个骨架图的图片，然后上传到 CDN，并给出页面路径和文件路径，生成配置文件给客户端，客户端根据配置加载骨架屏即可。")]),s._v(" "),t("p",[s._v("不过在实操时需要注意两点：")]),s._v(" "),t("ul",[t("li",[s._v("骨架屏中的内容结构，应该只是首屏的内容结构，不是整个页面的内容结构，反之会造成骨架图体积过大，加载骨架屏图片时间过长的问题；")]),s._v(" "),t("li",[s._v("骨架屏的问题，比如骨架屏代码异常加载时没有展示，或者展示时间过长，因为它不会影响白屏时间，我们很难发现。所以骨架屏什么时候展示和什么时候销毁，客户端要以日志形式记录下来，上传到性能监控平台，这样定期去看一下日志，则可以发现问题。")])]),s._v(" "),t("h3",{attrs:{id:"使用-ssr-方案优化页面性能"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#使用-ssr-方案优化页面性能"}},[s._v("#")]),s._v(" 使用 SSR 方案优化页面性能")]),s._v(" "),t("p",[s._v("一般来说，一个 Web 页面的渲染主要由客户端或者浏览器端来完成，大致过程是：客户端先从服务端请求到 index.html，然后加载脚本文件，Web 应用通过 ajax 请求到页面数据，并把相应的数据填充到模板，最终形成完整的页面来呈现给用户。")]),s._v(" "),t("p",[s._v("SSR（Server Side Rende，服务端渲染） 则把数据请求（也就是前面提到 ajax 请求）放在了服务端，服务端收到返回结果时，把数据填充到模板形成完整的页面，由服务器端把渲染完成的完整页面返回给客户端。这样减少了一些客户端到服务器端的数据接口请求，加快了首屏展现速度。")]),s._v(" "),t("p",[s._v("SSR 的实现及使用")]),s._v(" "),t("p",[s._v("如何实现 SSR 呢？我们选用了 nuxt.js 方案。")]),s._v(" "),t("p",[s._v("为什么选择它？因为手机业务迭代开发速度比较快，我们希望将 SSR 开发的一些配置都能够封装起来，让前端工程师介入成本降低。由于目前业界移动端使用 Vue 的比较多，所以寻找能和它配套的方案可以大大降低接入成本。而 Nuxt.js 正是这种方案，它是一款基于 Vue 的 SSR 开源框架，使用 Webpack 和 Node.js 进行封装，其中预设了开发服务端渲染应用所需要的各种配置。")]),s._v(" "),t("p",[s._v("具体到开发方面，官网文档介绍得比较详细，通过脚手架 npx 即可创建一个项目，然后进入 service-life目录，运行npm run dev，即可看到页面效果。")]),s._v(" "),t("div",{staticClass:"language-js line-numbers-mode"},[t("pre",{pre:!0,attrs:{class:"language-js"}},[t("code",[s._v("  npx create"),t("span",{pre:!0,attrs:{class:"token operator"}},[s._v("-")]),s._v("nuxt"),t("span",{pre:!0,attrs:{class:"token operator"}},[s._v("-")]),s._v("app service"),t("span",{pre:!0,attrs:{class:"token operator"}},[s._v("-")]),s._v("life\n  cd service"),t("span",{pre:!0,attrs:{class:"token operator"}},[s._v("-")]),s._v("life\n  npm run dev\n")])]),s._v(" "),t("div",{staticClass:"line-numbers-wrapper"},[t("span",{staticClass:"line-number"},[s._v("1")]),t("br"),t("span",{staticClass:"line-number"},[s._v("2")]),t("br"),t("span",{staticClass:"line-number"},[s._v("3")]),t("br")])]),t("p",[s._v("接下来我们来看如何在项目中接入 SSR 方案。因为移动端我们经常使用 Vue CSR ，和 Vue CSR 一致的地方（如 client 的 webpack 配置，项目基础结构等），在这里我就不过多介绍了，重点放在不同点上。")]),s._v(" "),t("p",[s._v("首先，一些基础要求要满足。一是如果没引入 Vuerouter、Vuex 和 axios，则需要引入，确保客户端拿到的数据和客户端一致。二是由于服务端也需要接收 URL，然后传递给 vue 程序进行处理，所以要做好跨平台的路由配置，具体可使用 Vuerouter。三是数据端也需要跨平台库，对应的技术是 axios + vuex。")]),s._v(" "),t("p",[s._v("其次，我们需要为 webpack 提供两个打包入口文件， client 端和 server 端各一份。")]),s._v(" "),t("p",[s._v("由于用户在客户端每次访问 vue 时，都是一个新的上下文，但在用户访问服务端时，用于服务端渲染的 Node.js 启动后就一直在运行。也就是说，每一个用户请求处理都在同一个应用上下文中进行。为了确保不串数据，需要为每次 SSR 请求，创建全新的 app、store 和 router。")]),s._v(" "),t("p",[s._v("然后，我们重构组件的数据获取方式，在页面开发渲染之前，利用服务端进程，做好数据获取和解析工作，然后把状态和数据存存储于 store 中。")]),s._v(" "),t("p",[s._v("这里面需要注意的是，SSR 应用在挂载（mount）到客户端应用程序之前，需要获取到与服务器端应用程序完全相同的数据。否则，客户端应用程序会因为使用与服务器端应用程序不同的状态，导致混合失败。")]),s._v(" "),t("h3",{attrs:{id:"白屏时间-100ms-的-ssr-优化"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#白屏时间-100ms-的-ssr-优化"}},[s._v("#")]),s._v(" 白屏时间 100ms 的 SSR 优化")]),s._v(" "),t("p",[s._v("做好上述工作后，我们白屏时间基本可以达到 200ms（标准是 300ms）。之后，我们还可以做一些升级优化，确保白屏时间达到 100ms 以内。具体来说，可以实施以下两个方面的工")]),s._v(" "),t("ul",[t("li",[s._v("利用服务端的性能优势，尽量在服务端完成资源加载、首屏切分等工作")]),s._v(" "),t("li",[s._v("利用服务端统一缓存机制，对数据接口、页面和组件做缓存")])]),s._v(" "),t("p",[s._v("第一，服务端渲染的最大优势，就是后端服务性能要远高于手机，所以请求数据接口和渲染时，耗时会更短。以我们手机业务列表页为例，CSR 下面渲染需要 600ms，到了 SSR下，渲染只需要 300ms。为此，我们可以把很多原本客户端做到的事情挪到了服务端，比如模块文件加载，首屏切分等。")]),s._v(" "),t("p",[s._v("第二，服务器端缓存与客户端最大不同是，服务端属于统一公用，也就是说，只要某一个用户访问过一次，后续所有用的访问都可以使用这份缓存。我们可以利用这一特点，采用 LRU（Least Recently Used，最近最少使用缓存机制）和 Redis 做好缓存功能，降低白屏时间。")]),s._v(" "),t("p",[s._v("具体来说，LRU 属于页面级缓存，对于数据统一性页面（有别于千人千面数据的页面），利用 LRU-Cache 可以缓存当前请求的数据资源。为了降低缓存的颗粒度，提高缓存的服用行，我们还可以用它来对渲染后的 vue 组件进行缓存。")]),s._v(" "),t("p",[s._v("而使用 Redis 可以对跨页面的数据接口进行缓存，将整体渲染时间再减少 100ms。为什么呢？因为 SSR 应用程序部署在多服务、多进程下，该进程下的缓存并不是共享的，这就造成缓存命中效率低下，而使用 Redis 可以解决这个问题，进而更好实现跨页面数据缓存（关联上跨云接口缓存这里，呼应主题）。")]),s._v(" "),t("p",[s._v("在实施过程中，还要注意以下几点：")]),s._v(" "),t("p",[s._v("第一，前端工程师因为对后端服务了解不多，在实际开发中可能会出现一些问题，例如我们之前遇到的，在服务端取后端数据接口时，取到的订单信息直接展示在页面源码中，导致乌云系统爆出了一个安全漏洞。所以建议你系统学习一些服务端安全知识，避免类似问题出现。")]),s._v(" "),t("p",[s._v("第二，在 SSR 服务出现高并发问题后，服务扩容是一种解决方案，但前端工程师对这方面并不擅长（如估算服务 QPS），容易出现问题。怎么办呢？一方面可以让运维和后端工程师一起协助，另外一方面也要做好 CSR 的降级，一旦遇到问题，可以快速降级。")]),s._v(" "),t("p",[s._v("小结\n"),t("img",{attrs:{src:"/performance/app-4.png",alt:"小结"}})]),s._v(" "),t("p",[s._v("好了，以上就是骨架屏和 SSR 性能优化方案。在实际当中，你可能会问了：SSR 说了这么多优点，为什么没全量普及，替代掉 CSR？")]),s._v(" "),t("p",[s._v("这是因为， SSR 需要你对后端知识，尤其是 Node.js 知识有很好地把握，且具备一定的数据接口设计规划和设计能力，但许多前端工程师很容易忽视这方面的学习。还有，SSR 渲染进行的页面，一些事件还在绑定中，有可能会出现操作没反应的情形；一些环境变量（如 window、document ）获取不到，稍不注意也会遇到内存泄漏的问题。")]),s._v(" "),t("p",[s._v("当然，这些对于白屏 100ms 的效果实现，都是非常值得的，而且前者可以通过提前安排Node.js 服务端开发相关培训来解决，后者可以通过整理一份 SSR 开发规范，将一步步蹚过的坑和宝贵经验沉淀下来。")]),s._v(" "),t("h2",{attrs:{id:"webview-性能优化"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#webview-性能优化"}},[s._v("#")]),s._v(" WebView 性能优化")]),s._v(" "),t("p",[s._v("WebView 是一个基于 WebKit 引擎、展现 Web 页面的控件， App 打开 WebView 的第一步不是请求连接，而是启动浏览器内核。这意味着，在浏览器端，我们输入地址就开始请求加载页面，但在 App 内，我们还需要先初始化 WebView 然后才能请求和加载。")]),s._v(" "),t("p",[s._v("这会造成什么结果呢？同一个页面，在 App 端外反而比端内打开速度更快。因为在 App 内，WebView 还需要先进行初始化，这需要时间，且这个初始化时间还和 WebView 类型有关。其中 Android 下只有一个 WebView，而iOS 下却分 UIWebView 和 WKWebView。以我们 iOS 端使用的 UIWebView 为例，需要 400ms 左右，如果是 WKWebView，时间会更短，但基本也会占首屏时间的 30%左右。")]),s._v(" "),t("p",[s._v("怎么解决这个问题呢？这就需要进行 WebView 优化了， 一般它的优化包括资源缓存、并行初始化、资源预加载和数据接口请求优化，以及更换 WebView 内核等。")]),s._v(" "),t("p",[s._v("其中缓存选用方面比较简单，直接选用的浏览器默认缓存。而更换 WebView 内核，往往会因为需要进行灰度处理，必须一段时间内（通常几个月）并行两套 WebView 方案，很容易出现系统性风险，比如修改一个严重 Bug 后，前端工程师不知道用户端什么时候生效。所以，在这里，我着重介绍下 WebView 优化里面的并行初始化、资源预加载、数据接口请求优化三个方案。")]),s._v(" "),t("h3",{attrs:{id:"并行初始化"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#并行初始化"}},[s._v("#")]),s._v(" 并行初始化")]),s._v(" "),t("p",[s._v("所谓并行初始化，是指用户在进入 App 时，系统就创建 WebView 和加载模板，这样 WebView 初始化和 App 启动就可以并行进行了，这大大减少了用户等待时间。")]),s._v(" "),t("p",[s._v("如果是使用 native 开发的应用，根据用户在首页的访问路径，选择初始化策略，操作体验会更好。以携程 App 为例，假设用户进入首页后，停留在西双版纳自由行区域，直接加载 WebView 和模板，两者同时运行，此时首屏主要工作就变成加载接口请求数据和渲染模板部分的工作了。")]),s._v(" "),t("p",[s._v("为了减少 WebView 再次初始化的时间，我们可以在使用完成后不进行注销，将里面数据清空，放进 WebView 池子里面，下次使用时，直接拿过来注入数据使用即可。注意，使用时，要对 WebView 池子进行容量限制，避免出现内存问题。")]),s._v(" "),t("p",[s._v("另外还需注意一点，由于初始化过程本身就需要时间，我们如果直接把它放到 UI 线程，会导致打开页面卡死甚至 ANR（Application Not Responding，应用无响应），所以，我建议将初始化过程放到子线程中，初始化结束后才添加到 View 树中。")]),s._v(" "),t("h3",{attrs:{id:"资源预加载"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#资源预加载"}},[s._v("#")]),s._v(" 资源预加载")]),s._v(" "),t("p",[s._v("资源预加载，是指提前在初始化的 WebView 里面放置一个静态资源列表，后续加载东西时，由于这部分资源已经被强缓存了，页面显示速度会更快。那么，要预加载的静态资源一般可以放哪些呢？")]),s._v(" "),t("p",[s._v("一定时间内（如 1 周）不变的外链；")]),s._v(" "),t("p",[s._v("一些基础框架，多端适配的 JS（如 adapter.js），性能统计的 JS（如 perf.js）或者第三方库（如 vue.js）；")]),s._v(" "),t("p",[s._v("基础布局的 CSS 如 base.css。")]),s._v(" "),t("p",[s._v("一般在 App 启动时，系统就加载一个带有通用资源模版的 HTML 页面，虽然这些静态资源不经常变化，但如果变化呢？怎么避免因变化导致 App 频繁发布版本的麻烦呢？")]),s._v(" "),t("p",[s._v("一个办法是通过静态资源预加载后台进行管理。具体的话，我们不需要从 0 到 1 搭建，只需要在离线包后台添加一个栏目即可。")]),s._v(" "),t("p",[s._v("在业务接入预加载功能时，前端工程师通过静态资源预加载后台发布出一个静态资源列表页，然后把它的 URL 提供给 App，App 启动时会对这个 URL 下页面中的静态资源进行预加载。之后，前端工程师就可以查看静态资源的编号 ID、URL 和类型，进行删除、添加等管理操作。")]),s._v(" "),t("p",[s._v("不要小看这一点，通过这种做法，我们手机列表页 13 个文件缓存后，首屏时间从 1050ms 降低到了 900ms。")]),s._v(" "),t("h3",{attrs:{id:"数据接口请求优化"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#数据接口请求优化"}},[s._v("#")]),s._v(" 数据接口请求优化")]),s._v(" "),t("p",[s._v("数据接口请求优化，主要是通过同域名策略和客户端代理数据请求来实现。")]),s._v(" "),t("p",[s._v("其中，同域名策略是指前端页面和资源加载，尽量和 App 使用的数据接口在同一个域名下，这样域名对应的 DNS 解析出来的 IP，由于已经在系统级别上被缓存过了，大大降低了加载时间。")]),s._v(" "),t("p",[s._v("比如，58 App 客户端请求域名主要集中在 api.58.com，请求完这个地址后，DNS 将会被系统缓存，而前端资源的请求地址在 i.58.com，打开 WebView 后，由于请求了不同的地址，还需要重新去 DNS 服务器去查询 i.58.com 对应的 IP，而如果前端也改到 api.58.com后，DNS 查询的时间可以从原来的将近 80ms 降低到几 ms。")]),s._v(" "),t("p",[s._v("客户端代理数据请求，则是指把前端的数据请求拦截起来，通过客户端去发送数据请求。因为正常的页面加载顺序是，前端在 HTML，CSS，JS 拉取下来之后才开始由 JS 发起前端的 ajax 请求，获取到数据后程序才开始进行填充。而我们通过客户端代理数据请求，可以把前端的 ajax 请求提前到与页面加载同时进行，由客户端请求数据，等 H5 加载完毕，直接向客户端索要即可。如此一来，便缩短了总体的页面加载时间。")]),s._v(" "),t("p",[s._v("注意，这里的数据拦截环节，Android 端可以重写WebViewClient的shouldInterceptRequest 方法，iOS 端没有类似的方法，只能通过私有 API 方案、自定义协议方案和 LocalWebServer 来实现。")]),s._v(" "),t("h2",{attrs:{id:"前端架构性能调优"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#前端架构性能调优"}},[s._v("#")]),s._v(" 前端架构性能调优")]),s._v(" "),t("p",[s._v("前端架构性能优化，是指通过在前端开发、编译、打包发布环节所作的优化，以此来提升前端性能的方案。因为我们比较关注首屏时间，对这方面贡献比较大的是开发和打包发布这两个环节，所以接下来我着重介绍下 Vue 开发过程中的长列表性能优化和 webpack 打包分析层面的优化。")]),s._v(" "),t("h3",{attrs:{id:"长列表性能优化"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#长列表性能优化"}},[s._v("#")]),s._v(" 长列表性能优化")]),s._v(" "),t("p",[s._v("一般，Vue 会借助 "),t("code",[s._v("Object.defineProperty")]),s._v(" 这个 ES5 规范的方法，对数据进行劫持，即通过在某个对象上定义一个新属性或者修改一个属性，实现视图响应数据的变化。")]),s._v(" "),t("p",[s._v("这会造成什么影响呢？")]),s._v(" "),t("p",[s._v("在一些纯展示的场景里面，比如电商列表页面，如果还允许 Vue 劫持我们的数据，会花费很多的组件初始化时间。这种情况下，怎么做呢？可以使用 "),t("code",[s._v("Object.freeze")]),s._v(" 冻结这个对象从而避免修改。")]),s._v(" "),t("div",{staticClass:"language-js line-numbers-mode"},[t("pre",{pre:!0,attrs:{class:"language-js"}},[t("code",[t("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("export")]),s._v(" "),t("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("default")]),s._v(" "),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("{")]),s._v("\n  "),t("span",{pre:!0,attrs:{class:"token function-variable function"}},[s._v("data")]),t("span",{pre:!0,attrs:{class:"token operator"}},[s._v(":")]),s._v(" "),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("(")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(")")]),s._v(" "),t("span",{pre:!0,attrs:{class:"token operator"}},[s._v("=>")]),s._v(" "),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("(")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("{")]),s._v(" "),t("span",{pre:!0,attrs:{class:"token literal-property property"}},[s._v("goodsList")]),t("span",{pre:!0,attrs:{class:"token operator"}},[s._v(":")]),s._v(" "),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("[")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("]")]),s._v(" "),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("}")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(")")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(",")]),s._v("\n  "),t("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("async")]),s._v(" "),t("span",{pre:!0,attrs:{class:"token function"}},[s._v("created")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("(")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(")")]),s._v(" "),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("{")]),s._v("\n    "),t("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("const")]),s._v(" goodsList "),t("span",{pre:!0,attrs:{class:"token operator"}},[s._v("=")]),s._v(" "),t("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("await")]),s._v(" "),t("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("this")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(".")]),s._v("$service"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(".")]),t("span",{pre:!0,attrs:{class:"token function"}},[s._v("get")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("(")]),t("span",{pre:!0,attrs:{class:"token string"}},[s._v('"/getGoodsList"')]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(")")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(";")]),s._v("\n    "),t("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("this")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(".")]),s._v("goodsList "),t("span",{pre:!0,attrs:{class:"token operator"}},[s._v("=")]),s._v(" Object"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(".")]),t("span",{pre:!0,attrs:{class:"token function"}},[s._v("freeze")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("(")]),s._v("goodsList"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(")")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(";")]),s._v("\n  "),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("}")]),s._v("\n"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("}")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(";")]),s._v("\n")])]),s._v(" "),t("div",{staticClass:"line-numbers-wrapper"},[t("span",{staticClass:"line-number"},[s._v("1")]),t("br"),t("span",{staticClass:"line-number"},[s._v("2")]),t("br"),t("span",{staticClass:"line-number"},[s._v("3")]),t("br"),t("span",{staticClass:"line-number"},[s._v("4")]),t("br"),t("span",{staticClass:"line-number"},[s._v("5")]),t("br"),t("span",{staticClass:"line-number"},[s._v("6")]),t("br"),t("span",{staticClass:"line-number"},[s._v("7")]),t("br")])]),t("p",[s._v("以前面提到的列表页面优化为例。我先定义一个 goodsList 的空对象，通过 async 将 created 钩子函数的返回值（也就是一个商品列表）封装成一个异步 Promise 对象，然后在 created 钩子函数中向 getGoodsList 接口获取数据。")]),s._v(" "),t("p",[s._v("其中，Vue 的生命周期里对外暴露的 created 钩子，表示 Vue 实例被创建但还没有渲染到浏览器的阶段；await 表示当拿到返回的数据结果后，Vue 实例才会通过 "),t("code",[s._v("Object.freeze")]),s._v(" 把 goodsList 结果冻结，即 goodsList 对象展示过程中，数据变化时，视图将不再更新。")]),s._v(" "),t("p",[s._v("通过以上步骤，最终提升商品列表页的性能。")]),s._v(" "),t("h3",{attrs:{id:"打包优化"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#打包优化"}},[s._v("#")]),s._v(" 打包优化")]),s._v(" "),t("p",[s._v("打包优化方面，我们可以通过 webpack 插件来完成。 wepack 输出的代码可读性较差，而且文件比较大，我们很难了解打包后的情况，更别说如何优化了。为了直观分析打包结果，我们可以使用一个 webpack 插件——webpack-bundle-analyzer，通过它可以对打包结果进行可视化分析。")]),s._v(" "),t("p",[s._v("具体怎么实现呢？")]),s._v(" "),t("p",[s._v("我们在 wepack 中加入以下代码来实现打包分析。")]),s._v(" "),t("div",{staticClass:"language-js line-numbers-mode"},[t("pre",{pre:!0,attrs:{class:"language-js"}},[t("code",[s._v("  module"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(".")]),s._v("exports "),t("span",{pre:!0,attrs:{class:"token operator"}},[s._v("=")]),s._v(" "),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("{")]),s._v("\n    "),t("span",{pre:!0,attrs:{class:"token comment"}},[s._v("// vue-cli3 提供的一种高级技巧，链式操作")]),s._v("\n    "),t("span",{pre:!0,attrs:{class:"token function"}},[s._v("chainWebpack")]),s._v(" "),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("(")]),t("span",{pre:!0,attrs:{class:"token parameter"}},[s._v("config")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(")")]),s._v(" "),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("{")]),s._v("\n      "),t("span",{pre:!0,attrs:{class:"token comment"}},[s._v("// 意思只在打包时起作用")]),s._v("\n      "),t("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("if")]),s._v(" "),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("(")]),s._v("process"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(".")]),s._v("env"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(".")]),t("span",{pre:!0,attrs:{class:"token constant"}},[s._v("NODE_ENV")]),s._v(" "),t("span",{pre:!0,attrs:{class:"token operator"}},[s._v("===")]),s._v(" "),t("span",{pre:!0,attrs:{class:"token string"}},[s._v("'production'")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(")")]),s._v(" "),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("{")]),s._v("\n        config"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(".")]),t("span",{pre:!0,attrs:{class:"token function"}},[s._v("plugin")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("(")]),t("span",{pre:!0,attrs:{class:"token string"}},[s._v("'webpack-bundle-analyzer'")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(")")]),s._v("\n          "),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(".")]),t("span",{pre:!0,attrs:{class:"token function"}},[s._v("use")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("(")]),t("span",{pre:!0,attrs:{class:"token function"}},[s._v("require")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("(")]),t("span",{pre:!0,attrs:{class:"token string"}},[s._v("'webpack-bundle-analyzer'")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(")")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(".")]),s._v("BundleAnalyzerPlugin"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(")")]),s._v("\n          "),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(".")]),t("span",{pre:!0,attrs:{class:"token function"}},[s._v("end")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("(")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(")")]),s._v("\n      "),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("}")]),s._v("\n    "),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("}")]),s._v("\n  "),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("}")]),s._v("\n")])]),s._v(" "),t("div",{staticClass:"line-numbers-wrapper"},[t("span",{staticClass:"line-number"},[s._v("1")]),t("br"),t("span",{staticClass:"line-number"},[s._v("2")]),t("br"),t("span",{staticClass:"line-number"},[s._v("3")]),t("br"),t("span",{staticClass:"line-number"},[s._v("4")]),t("br"),t("span",{staticClass:"line-number"},[s._v("5")]),t("br"),t("span",{staticClass:"line-number"},[s._v("6")]),t("br"),t("span",{staticClass:"line-number"},[s._v("7")]),t("br"),t("span",{staticClass:"line-number"},[s._v("8")]),t("br"),t("span",{staticClass:"line-number"},[s._v("9")]),t("br"),t("span",{staticClass:"line-number"},[s._v("10")]),t("br"),t("span",{staticClass:"line-number"},[s._v("11")]),t("br")])]),t("p",[s._v("这里面 chainWebpack 是 vue3 提供的一种高级操作——链式操作，通过它可以快捷完成一些方法的调用。代码中添加 process.env.NODE_ENV === 'production'是为了让代码只在打包时起作用。\n做完以上操作后，运行 npm run build --report，即可后生成一个分析报告。")]),s._v(" "),t("p",[t("img",{attrs:{src:"/performance/app-5.png",alt:"打包优化"}})]),s._v(" "),t("p",[s._v("当我们拿着鼠标在上面滑动时，就可以看到整个包的组成部分，以及每部分的信息。一般我们可以找内容比较大的方面，然后分析原因进行优化。")]),s._v(" "),t("p",[s._v("比如，有次游戏业务发现打包目录超过了10MB，仔细定位发现是有些 game.map 的文件打包上来了。虽然 game.map 文件便于我们开发时调解 bug，准确定位错误的位置，但在这里却影响了我们的性能体验。找到原因后，解决它也很简单了，直接在打包时，关闭 sourcemap，即在配置文件中增加productionSourceMap:false 就可以了。")]),s._v(" "),t("p",[s._v("小结\n好了，以上就是 WebView 性能优化和代码架构层的优化，这里面有一些注意事项。WebView 会占用一定的内存，如果使用 WebView 缓存池进行优化，会出现内存占用多的问题，我们可以将 WebView 放到独立进程中，避免内存泄漏。当然，WebView 独立进程的话，就需要解决进程间调用问题，一般可以直接使用 Aidl 来解决。")]),s._v(" "),t("h2",{attrs:{id:"预请求"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#预请求"}},[s._v("#")]),s._v(" 预请求")]),s._v(" "),t("p",[s._v("想要通过拉取后端接口来降低首屏时间，我们需要先实现接口的预加载。而实现它要先解决预请求的逻辑，也就是统一拼装请求参数的逻辑。")]),s._v(" "),t("p",[s._v("具体怎么进行统一拼参呢？这就涉及前端正常的数据请求过程了。")]),s._v(" "),t("p",[s._v("以机票业务为例，我们进入列表页后，输入出发地和目的地后，比如从北京到深圳，选择日期为 2021-06-06，前端应用通过解析页面 URL 路径，拿到所需的一些参数（如 from=shanghai&to=beijing&date=20210606），然后调用 Native 的 schema 进入参数解析环节，找到 Native 对应的协议和参数（如://search？terminal=app），然后再通过参数初始化，拼装成对应的参数（如://search?terminal=app&from=shanghai&to=beijing&date=20210606）。")]),s._v(" "),t("p",[s._v("如果预请求走上述流程的话，面临的一个问题是，没有预请求的页面 URL 参数，也没法通过 Native 获取到。这需要自己根据逻辑拼装，所以往往会单独做出一套流程，结果就是不但容易出错，还会因为需要用类似两份代码去实现这个功能，反过来拉长页面的首屏时间。所以，我们使用了同样的流程，将预请求封装成preReq 功能，把所有的功能都包括起来，用同一份代码实现。")]),s._v(" "),t("p",[s._v("在做完这个统一拼参逻辑后，预请求实现起来就容易了。具体来说，如果你已经使用了 Native 统一请求，直接走客户端逻辑发送即可。如果还没有走 Native 统一请求，")]),s._v(" "),t("p",[s._v("我们可以借助Axios 库函数来完成。")]),s._v(" "),t("p",[s._v("第一步，我们需要封装一下 Axios 库函数，在 post 和 get 之前，通过添加一个钩子函数 BeforeFetch，对 URL 参数进行解析和 Native 参数补全。")]),s._v(" "),t("p",[s._v("第二步，业务侧使用与请求时，因为 Axios 库是整体打包引入的，所以使用时，可以直接使用 Axios.fetch 方法来实现预请求功能。")]),s._v(" "),t("h2",{attrs:{id:"预加载"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#预加载"}},[s._v("#")]),s._v(" 预加载")]),s._v(" "),t("p",[s._v("在完成预请求参数拼装之后，紧接着就是预加载逻辑了。首先是要把握预加载的时机。以机票列表页为例，我们需要判断用户操作的特定路径。如果用户操作命中了这个特定路径，就会做预加载，去请求列表页的接口。")]),s._v(" "),t("p",[s._v("这个路径是我们和后端的一个约定，有具体的编号，比如用户“进入首页”编号是 0，“输入出发地和目的地”操作路径是 1，“输入日期”操作路径是 2，“切换关键词”是 3，点击“我的位置”是 4。")]),s._v(" "),t("p",[s._v("后端在用户进入列表页时，以接口的方式返回一个操作路径的数组，当用户的操作路径命中这个数组后，比如 [1,2,3]，意思是用户从首页进入，选择了出发地和目的地，并且输入了日期，接下来开始进行预加载。")]),s._v(" "),t("p",[s._v("当用户点击“开始搜索”后，前端应用就会去判断有没有预加载下级页面（搜索页面）的接口，是否有搜索页的预加载数据，而且这个数据又没有过期，就直接跳转下级页；如果没有可用的预加载数据，此时我们进行一次搜索页的预加载，减少从列表页到搜索页的跳转时间和搜索页的初始化时间。")]),s._v(" "),t("p",[s._v("预加载是怎么实现的呢？如果 Native 已经提供这个功能，我们直接使用 Native 的预加载接口即可。反之，我们还是需要扩展 Axios 库函数来实现。")]),s._v(" "),t("p",[s._v("具体来说，在 Axios 进行数据请求后，封装一个 afterFetch 的钩子方法，负责将加载完成的数据存储到本地，供下一个路由使用。这就完成了预加载。当业务侧使用时，先在 aftereFetch 钩子里面定义好取到数据后做什么，然后直接使用 fetch 方法即可。")]),s._v(" "),t("p",[s._v("比如手机列表页，有一个场景是提前获取下一页的数据做排版，数据预加载完成后，在 afterFetch 里面就会将这些数据存储到内存中。")]),s._v(" "),t("p",[s._v("需要注意的是，即便是预加载，也要做好缓存处理。 我们要先在内存里面 check 一下是否存在之前预加载的数据。有的话，直接用预加载数据，做后续操作，如果没有，就继续走预加载逻辑，然后设置缓存数据。")]),s._v(" "),t("h2",{attrs:{id:"预渲染"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#预渲染"}},[s._v("#")]),s._v(" 预渲染")]),s._v(" "),t("p",[s._v("预渲染是指在用户访问这个页面之前，完成页面渲染的准备。还是以机票列表页为例，比如说用户命中特定路径的时候，前端进行判断并会把搜索结果页先渲染出来，只不过在列表页可视区域下方，用户是不可见的。")]),s._v(" "),t("p",[s._v("当用户点击开始搜索时，前端会去 check，如果已经有了预渲染的页面，只需要把页面显示出来的操作， push 到顶层即可。这样就省去了初始化页面、请求数据和渲染的时间。")]),s._v(" "),t("p",[s._v("具体怎么实现呢？这就需要用到 “客户端”渲染技术了。你看我在这里加了个引号，其实就是说，它有别于 CSR，而是 NSR（Native side rendering，客户端渲染），即通过客户端（Native 侧）进行页面结构拼接，进而实现页面渲染的处理技术。具体见下图所示。")]),s._v(" "),t("p",[t("img",{attrs:{src:"/performance/app-6.png",alt:"预渲染"}})]),s._v(" "),t("p",[s._v("NSR 优化时，需要离线包提供模板等资源（如 HTML、JS、CSS ），预加载提供数据，把页面作为数据经过模板函数变化后产生的结果，然后通过 v8 引擎在客户端渲染出来。")]),s._v(" "),t("p",[s._v("NSR 是怎么实现的呢？")]),s._v(" "),t("p",[s._v("首先是模板和数据的准备，用户点击页面链接进入后，这个页面的所有资源是准备好的。具体可以使用前面几讲提到的离线包，以及预请求和预加载方案来做。")]),s._v(" "),t("p",[s._v("其次，由于页面是动态的而 URL 是静态的，需要实现一种页面与模版的映射机制，一般为多对一，这个机制有助于 Native 快速定位到所需模版。")]),s._v(" "),t("p",[s._v("最后，在 Native 侧实现一种类似前文 SSR 方案的 Native 本地渲染服务。")]),s._v(" "),t("p",[s._v("实现完 NSR 之后，业务就可以使用预渲染功能了。在使用时，前端代码不需要做什么改动，业务侧前端工程师接入 NSR，把后置流程准备好就可以了。所谓的后置流程，就是指渲染好下级页面后放置在可视区域之外。")]),s._v(" "),t("p",[s._v("这里需要注意的一个点是，NSR 是在端内渲染的场景，如果是端外怎么办呢？端外就是纯前端的渲染了，下面以我曾经做过的一个案例和你介绍下。")]),s._v(" "),t("p",[s._v("当时，公司有个文档内容展现平台，在对文档进行展现时，需要用到虚拟页，即要展示的文档的页码会根据页面内容动态变化，比如在电脑上是展示 1000 字/页，到手机上变成了 120 字/页。这样同一篇文档，在不同平台上显示，需要切割分页，但该操作需要一定的时间。")]),s._v(" "),t("p",[s._v("所以最好的办法是，当展示第 1 页的时候，就预先渲染第 3 页的内容。具体怎么实现呢？我们是这么做的，在展示第 T 页的时候，在可视范围之外，做 T+2 页的数据切割，切割完进行渲染，渲染完成后放在原地，等点击第 T+2 页时，移动回来。")]),s._v(" "),t("p",[s._v("预渲染，有时会遇到内存问题，我们可以精简预渲染的内容，比如一些图片资源，可以延后获取。")]),s._v(" "),t("p",[s._v("小结\n好了，以上就是预请求、预加载及预渲染相关的内容。在实际当中，你可能会遇到预加载和预渲染需要降级的问题，比如没有拿到数据的兜底兼容流程，可以继续使用 CSR，同时如果在端外无法使用离线包，则使用 SSR 是一种很好的替代方案。")])])}),[],!1,null,null,null);t.default=n.exports}}]);