(window.webpackJsonp=window.webpackJsonp||[]).push([[79],{502:function(v,_,a){"use strict";a.r(_);var t=a(15),e=Object(t.a)({},(function(){var v=this,_=v.$createElement,a=v._self._c||_;return a("ContentSlotsDistributor",{attrs:{"slot-key":v.$parent.slotKey}},[a("h2",{attrs:{id:"复杂度"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#复杂度"}},[v._v("#")]),v._v(" 复杂度")]),v._v(" "),a("h3",{attrs:{id:"时间维度"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#时间维度"}},[v._v("#")]),v._v(" 时间维度")]),v._v(" "),a("p",[v._v("是指执行当前算法所消耗的时间，我们通常用「时间复杂度」来描述。")]),v._v(" "),a("p",[v._v("大O符号表示法 T(n) = O(f(n)),其中f(n) 表示每行代码执行次数之和，而 O 表示正比例关系，这个公式的全称是：算法的渐进时间复杂度。")]),v._v(" "),a("ul",[a("li",[v._v("常数阶"),a("code",[v._v("O(1)")]),v._v(" :无论代码执行了多少行，只要是没有循环等复杂结构，那这个代码的时间复杂度就都是O(1)")]),v._v(" "),a("li",[v._v("线性阶"),a("code",[v._v("O(n)")]),v._v(": for循环里面的代码会执行n遍，因此它消耗的时间是随着n的变化而变化的，因此这类代码都可以用O(n)来表示它的时间复杂度。")]),v._v(" "),a("li",[v._v("对数阶"),a("code",[v._v("O(logN)")]),v._v(" :"),a("code",[v._v("while(i<n){ i = i * 2;}")]),v._v("假设循环x次之后，i 就大于 2 了，此时这个循环就退出了，也就是说 2 的 x 次方等于 n，那么 x = log2^n 也就是说当循环 log2^n 次以后，这个代码就结束了。因此这个代码的时间复杂度为：O(logn)")]),v._v(" "),a("li",[v._v("线性对数阶"),a("code",[v._v("O(nlogN)")]),v._v(" :线性对数阶O(nlogN) 其实非常容易理解，将时间复杂度为O(logn)的代码循环N遍的话，那么它的时间复杂度就是 n * O(logN)，也就是了O(nlogN)")]),v._v(" "),a("li",[v._v("平方阶"),a("code",[v._v("O(n²)")]),v._v(": 平方阶O(n²) 就更容易理解了，如果把 O(n) 的代码再嵌套循环一遍，它的时间复杂度就是 O(n²) 了。")]),v._v(" "),a("li",[v._v("立方阶"),a("code",[v._v("O(n³)")]),v._v(": ，O(n³)相当于三层n循环，其它的类似。")]),v._v(" "),a("li",[v._v("K次方阶"),a("code",[v._v("O(n^k)")])]),v._v(" "),a("li",[v._v("指数阶"),a("code",[v._v("(2^n)")])])]),v._v(" "),a("h3",{attrs:{id:"空间维度-是指执行当前算法需要占用多少内存空间-我们通常用「空间复杂度」来描述。"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#空间维度-是指执行当前算法需要占用多少内存空间-我们通常用「空间复杂度」来描述。"}},[v._v("#")]),v._v(" 空间维度：是指执行当前算法需要占用多少内存空间，我们通常用「空间复杂度」来描述。")]),v._v(" "),a("p",[v._v("空间复杂度是对一个算法在运行过程中临时占用存储空间大小的一个量度，同样反映的是一个趋势，我们用 S(n) 来定义。")]),v._v(" "),a("ul",[a("li",[a("p",[a("code",[v._v("O(1)")]),v._v(" :如果算法执行所需要的临时空间不随着某个变量n的大小而变化，即此算法空间复杂度为一个常量，可表示为 O(1)")])]),v._v(" "),a("li",[a("p",[a("code",[v._v("O(n)")])]),v._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",[a("code",[v._v("```js\nint[] m = new int[n]\nfor(i=1; i<=n; ++i){\n  j = i;\n  j++;\n}\n// 这段代码中，第一行new了一个数组出来，这个数据占用的大小为n，这段代码的2-6行，虽然有循环，但没有再分配新的空间，因此，这段代码的空间复杂度主要看第一行即可，即 S(n) = O(n)\n```\n")])])])])]),v._v(" "),a("h2",{attrs:{id:"数据结构"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#数据结构"}},[v._v("#")]),v._v(" 数据结构")]),v._v(" "),a("h3",{attrs:{id:"数组"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#数组"}},[v._v("#")]),v._v(" 数组")]),v._v(" "),a("p",[v._v("特点: 数据连续,随机访问(根据地址访问第N个数据)")]),v._v(" "),a("p",[v._v("增删改查: 增删,值的查找为 O(n) 索引查找为O(1)")]),v._v(" "),a("h3",{attrs:{id:"链表"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#链表"}},[v._v("#")]),v._v(" 链表")]),v._v(" "),a("p",[v._v("特点: 非连续存储, 只标记上下元素")]),v._v(" "),a("ol",[a("li",[v._v("react的fiber,存储了数你dom树的链表")]),v._v(" "),a("li",[v._v("vue内部的keep-live,缓存算法LRU用的链表")]),v._v(" "),a("li",[v._v("数组与链表结合成了其出他数据结构")])]),v._v(" "),a("h3",{attrs:{id:"tree"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#tree"}},[v._v("#")]),v._v(" tree")]),v._v(" "),a("p",[v._v("树是一种数据结构，它是由n（n>=1）个有限节点组成一个具有层次关系的集合。把它叫做 “树” 是因为它看起来像一棵倒挂的树，也就是说它是根朝上，而叶朝下的。它具有以下的特点：")]),v._v(" "),a("ul",[a("li",[v._v("每个节点有零个或多个子节点；")]),v._v(" "),a("li",[v._v("没有父节点的节点称为根节点；")]),v._v(" "),a("li",[v._v("每一个非根节点有且只有一个父节点；")]),v._v(" "),a("li",[v._v("除了根节点外，每个子节点可以分为多个不相交的子树；")]),v._v(" "),a("li",[v._v("在日常的应用中，我们讨论和用的更多的是树的其中一种结构，就是二叉树。")])]),v._v(" "),a("h3",{attrs:{id:"栈"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#栈"}},[v._v("#")]),v._v(" 栈")]),v._v(" "),a("p",[v._v("栈是一种特殊的线性表，仅能在线性表的一端操作，栈顶允许操作，栈底不允许操作。 栈的特点是：先进后出，或者说是后进先出，从栈顶放入元素的操作叫入栈，取出元素叫出栈。栈的结构就像一个集装箱，越先放进去的东西越晚才能拿出来，所以，栈常应用于实现递归功能方面的场景，例如斐波那契数列。")]),v._v(" "),a("h3",{attrs:{id:"队列"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#队列"}},[v._v("#")]),v._v(" 队列")]),v._v(" "),a("p",[v._v("队列与栈一样，也是一种线性表，不同的是，队列可以在一端添加元素，在另一端取出元素，也就是：先进先出。从一端放入元素的操作称为入队，取出元素为出队，因为队列先进先出的特点，在多线程阻塞队列管理中非常适用。")]),v._v(" "),a("h3",{attrs:{id:"散列表-哈希表"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#散列表-哈希表"}},[v._v("#")]),v._v(" 散列表(哈希表)")]),v._v(" "),a("p",[v._v("散列表，也叫哈希表，是根据关键码和值 (key和value) 直接进行访问的数据结构，通过key和value来映射到集合中的一个位置，这样就可以很快找到集合中的对应元素。记录的存储位置=f(key)")]),v._v(" "),a("p",[v._v("这里的对应关系 f 成为散列函数，又称为哈希 (hash函数)，而散列表就是把Key通过一个固定的算法函数既所谓的哈希函数转换成一个整型数字，然后就将该数字对数组长度进行取余，取余结果就当作数组的下标，将value存储在以该数字为下标的数组空间里，这种存储空间可以充分利用数组的查找优势来查找元素，所以查找的速度很快。")]),v._v(" "),a("h3",{attrs:{id:"堆"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#堆"}},[v._v("#")]),v._v(" 堆")]),v._v(" "),a("p",[v._v("堆是一种比较特殊的数据结构，可以被看做一棵树的数组对象，具有以下的性质：")]),v._v(" "),a("ul",[a("li",[v._v("堆中某个节点的值总是不大于或不小于其父节点的值；")]),v._v(" "),a("li",[v._v("堆总是一棵完全二叉树。")]),v._v(" "),a("li",[v._v("将根节点最大的堆叫做最大堆或大根堆，根节点最小的堆叫做最小堆或小根堆。常见的堆有二叉堆、斐波那契堆等。")])]),v._v(" "),a("h3",{attrs:{id:"图"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#图"}},[v._v("#")]),v._v(" 图")]),v._v(" "),a("p",[v._v("图是由结点的有穷集合V和边的集合E组成。其中，为了与树形结构加以区别，在图结构中常常将结点称为顶点，边是顶点的有序偶对，若两个顶点之间存在一条边，就表示这两个顶点具有相邻关系。图是一种比较复杂的数据结构，在存储数据上有着比较复杂和高效的算法，分别有邻接矩阵 、邻接表、十字链表、邻接多重表、边集数组等存储结构")])])}),[],!1,null,null,null);_.default=e.exports}}]);