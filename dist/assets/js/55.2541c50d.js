(window.webpackJsonp=window.webpackJsonp||[]).push([[55],{480:function(e,v,t){"use strict";t.r(v);var _=t(15),o=Object(_.a)({},(function(){var e=this,v=e.$createElement,t=e._self._c||v;return t("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[t("h2",{attrs:{id:"生命周期"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#生命周期"}},[e._v("#")]),e._v(" 生命周期")]),e._v(" "),t("h3",{attrs:{id:"react-16-前的生命周期函数"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#react-16-前的生命周期函数"}},[e._v("#")]),e._v(" React 16 前的生命周期函数")]),e._v(" "),t("p",[t("img",{attrs:{src:"/React/lifescale16.png",alt:"React 16 前的生命周期函数"}})]),e._v(" "),t("ol",[t("li",[e._v("组件初始化("),t("code",[e._v("Initialization")]),e._v(")阶段\n"),t("ul",[t("li",[e._v("初始化"),t("code",[e._v("state")]),e._v("和"),t("code",[e._v("props")]),e._v("的数据")])])]),e._v(" "),t("li",[e._v("组件的挂载("),t("code",[e._v("Mounting")]),e._v(")阶段\n"),t("ul",[t("li",[t("code",[e._v("componentWillMount")]),e._v(" (React v16 弃用)")]),e._v(" "),t("li",[t("code",[e._v("render")])]),e._v(" "),t("li",[t("code",[e._v("componentDidMount")])])])]),e._v(" "),t("li",[e._v("组件的更新("),t("code",[e._v("Updation")]),e._v(")阶段 (1.父组件重新 "),t("code",[e._v("render")]),e._v(" 导致的重传 "),t("code",[e._v("props")]),e._v(" 2. 组件本身调用 "),t("code",[e._v("setState")]),e._v("，无论 "),t("code",[e._v("state")]),e._v(" 有没有变化。)\n"),t("ul",[t("li",[t("code",[e._v("componentWillReceiveProps")]),e._v(" (React v16 弃用)")]),e._v(" "),t("li",[t("code",[e._v("shouldComponentUpdate")])]),e._v(" "),t("li",[t("code",[e._v("componentWillUpdate")])]),e._v(" "),t("li",[t("code",[e._v("render")]),e._v("(这里只是重新调用)")]),e._v(" "),t("li",[t("code",[e._v("componentDidUpdate")])])])]),e._v(" "),t("li",[e._v("组件的卸载("),t("code",[e._v("Unmounting")]),e._v(")阶段\n"),t("ul",[t("li",[t("code",[e._v("componentWillUnmount")])])])])]),e._v(" "),t("h3",{attrs:{id:"react-v16-4-的生命周期"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#react-v16-4-的生命周期"}},[e._v("#")]),e._v(" React v16.4 的生命周期")]),e._v(" "),t("p",[t("img",{attrs:{src:"/React/lifescale16.1.png",alt:"React v16.4 的生命周期"}})]),e._v(" "),t("ol",[t("li",[e._v("挂载阶段\n"),t("ul",[t("li",[t("code",[e._v("constructor")])]),e._v(" "),t("li",[t("code",[e._v("getDrivedStateFromProps")])]),e._v(" "),t("li",[t("code",[e._v("render")])]),e._v(" "),t("li",[t("code",[e._v("componentDidMount")])])])]),e._v(" "),t("li",[e._v("更新阶段\n"),t("ul",[t("li",[t("code",[e._v("getDrivedStateFromProps")])]),e._v(" "),t("li",[t("code",[e._v("shouldComponentUpdate")])]),e._v(" "),t("li",[t("code",[e._v("getShanpshotBeforeUpdate")])]),e._v(" "),t("li",[t("code",[e._v("componentDidUpdate")])])])]),e._v(" "),t("li",[e._v("卸载阶段\n"),t("ul",[t("li",[t("code",[e._v("componentWillUnmount")])])])])]),e._v(" "),t("p",[t("code",[e._v("React")]),e._v(" 以前是同步更新，如果更新的组件过多，就会阻塞线程，用户有操作无法立即响应，界面卡顿，影响用户体验。然后React v16推出的 "),t("code",[e._v("React Fiber")]),e._v(", 原来（React v16.0前）的生命周期再"),t("code",[e._v("React Fiber")]),e._v("后就不合适了, 在 "),t("code",[e._v("render")]),e._v(" 函数执行之前的所有函数都有可能执行多次。")]),e._v(" "),t("h2",{attrs:{id:"react-fiber"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#react-fiber"}},[e._v("#")]),e._v(" React Fiber")]),e._v(" "),t("p",[e._v("破解JavaScript中同步操作时间过长的方法其实很简单——分片。")]),e._v(" "),t("p",[e._v("把一个耗时长的任务分成很多小片，每一个小片的运行时间很短，虽然总时间依然很长，但是在每个小片执行完之后，都给其他任务一个执行的机会，这样唯一的线程就不会被独占，其他任务依然有运行的机会。")]),e._v(" "),t("p",[t("code",[e._v("React Fiber")]),e._v("把更新过程碎片化，执行过程中，每执行完一段更新过程，就把控制权交还给React负责任务协调的模块，看看有没有其他紧急任务要做，如果没有就继续去更新，如果有紧急任务，那就去做紧急任务。")]),e._v(" "),t("p",[e._v("维护每一个分片的数据结构，就是Fiber。")]),e._v(" "),t("p",[t("code",[e._v("Fiber")]),e._v(" 是如何工作的")]),e._v(" "),t("p",[e._v("现在我们知道了开发 "),t("code",[e._v("fiber")]),e._v(" 的动机，让我们总结下需要实现的特性。")]),e._v(" "),t("p",[e._v("再一次引用 Andrew Clark’s 的笔记：")]),e._v(" "),t("p",[e._v("为不同类型的任务赋予优先级\n任务的暂停与恢复\n如果任务不再需要，可以中止\n复用之前已完成的工作")]),e._v(" "),t("p",[t("code",[e._v("JavaScript")]),e._v(" 执行栈\n"),t("code",[e._v("fiber")]),e._v(" 节点的单向链表")])])}),[],!1,null,null,null);v.default=o.exports}}]);