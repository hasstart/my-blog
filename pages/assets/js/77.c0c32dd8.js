(window.webpackJsonp=window.webpackJsonp||[]).push([[77],{503:function(e,o,s){"use strict";s.r(o);var n=s(15),i=Object(n.a)({},(function(){var e=this,o=e.$createElement,s=e._self._c||o;return s("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[s("p",[e._v("session/cookie")]),e._v(" "),s("ol",[s("li",[e._v("什么是状态管理\n将客户端(浏览器)与服务器之间多次交互当作一个整体来看，并将多次交互所涉及的数据(状态)保存下来。")]),e._v(" "),s("li",[e._v("如何进行状态管理")])]),e._v(" "),s("ul",[s("li",[e._v("第一类方式：将状态保存在客户端（Cookie）\n服务端存储一个 session对象 {key: value} key放置cookie中 通过cookie的key取到value value就不用暴露至客户端\na. cookie是一种客户端的状态管理技术\nb. 当浏览器向服务器发送请求时，服务器会将少量的数据以set-cookie消息头的方式发送给浏览器，浏览器会将这些数据保存下来。当浏览器再次访问服务器时，会将这些数据以cookie消息头的方式发送给服务器。\nc. cookie可被用户禁止。\nd. cookie不安全,敏感数据，比如密码，帐号等等需加密。\ne. cookie大小有限制，大约是4k左右(具体大小跟浏览器有关)。\nf. cookie个数有限制，大约是300个(具体个数跟浏览器有关)。\ng.  cookie只能够保存字符串。")]),e._v(" "),s("li",[e._v("第二类方式: 将状态保存在服务器端(Session)\na. session是一种服务器端的状态管理技术。\nb. 当浏览器访问服务器时，服务器创建一个session对象(该对象有一个唯一的id号，称之为sessionId),服务器在默认情况下，会将sessionId以cookie的方式(set-cookie消息头)发送给浏览器,浏览器会将sessionId保存到内存。当浏览器再次访问服务器时，会将sessionId发送给服务器，服务器依据sessionId就可找到之前创建的session对象。")])]),e._v(" "),s("p",[e._v("Token(JWT)")]),e._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",[s("code",[e._v("      令牌头 payload hash\n")])])]),s("p",[e._v("token结构 base64·base64· hash")]),e._v(" "),s("ol",[s("li",[e._v("签名: 默认使用base64对payload编码,使用hs256算法对令牌头,payload和密钥进行签名生成哈希")]),e._v(" "),s("li",[e._v("验证: 默认使用hs256算法对令牌中数据签名并将结果和令牌中哈希对比")])]),e._v(" "),s("p",[e._v("Oauth2")]),e._v(" "),s("p",[e._v("客户端 => 服务器 拉取github 页面 => 登录 => 返回code => 使用code换取令牌")]),e._v(" "),s("p",[e._v("SSO")]),e._v(" "),s("p",[e._v("单点登录 => A 跳转至认证服务器 => 登录返回token => 核实token 放入登录态至A > B登录 在认证服务器查询登录 有则直接返回")])])}),[],!1,null,null,null);o.default=i.exports}}]);